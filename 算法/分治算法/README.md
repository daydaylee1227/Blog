## 前言

这次分享的内容是，经典算法思想-分治，你可以把它称之为一种思想，也可以叫它分治算法，为了更好的区分，接下来我们以'分治法'来称呼它。





如果你还不了解什么是分治法，或者知道一些，但是对于它具体是如何实现`回溯`，那么这篇文章可能适合你阅读。



> 我对分治算法的理解：
>
> 它的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。
>
> 求出子问题的解，就可得到原问题的解，可以理解成一种分目标完成程序的算法。
>
> 二分法很多时候，就是一种分治的思想。





那么围绕以下几个点来展开介绍分治算法👇

- 基本思路
- 算法框架
- 经典例题



联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。



--------------------







## 基本思想

一句话，对分治法概括它的话👇

将原问题划分成n个规模较小而结构与原问题相似的子问题，递归去解决这些子问题，然后依次再合并其结果，最后得到原问题的解。



那么具体的来说，我们似乎可以分成三个步骤👇

- 分解：将要解决的问题划分成若干规模较小的同类问题。
- 解决：当子问题划分得足够小时，用较简单的方法解决。
- 合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。



其实思想还是不变的，将一个难以直接解决的大问题，分割成一些小规模的相同问题，以便各个击破，分而治之。







----------





## 算法框架

其实刷了一定的题量，你会发现，对于这种回溯思路而言，都是有一定的套路的，那么接下来就给出伪代码👇

接下来是自己的一点理解，觉得按照这个步骤来的话，也好理解一些👇

可以按照3个步骤来思考这类的问题：

1. **路径**：记录做出的选择。
2. **选择列表**：通常而言，用数组存储可以选择的操作。
3. **结束条件**：一般而言，就是递归的结束点，也就是搜索的结束点。



```js
result = []

function backtrack(路径, 选择列表) {
    if('满足结束条件') {
        // 这里就是对答案做更新,依据实际题目出发
        result.push(路径)
        return
    } else {
        for(let i = 0; i < 选择列表.length; i++) {
            // 对一个选择列表做相应的选择
            
            做选择
            
            backtrack(路径, 选择列表)
            
            // 既然是回溯算法,那么在一次分岔路做完选择后
            // 需要回退我们之前做的操作
            
            撤销选择
        }
    }
}
```



做过类似的题目都知道，核心的处理就是for循环里面的递归操作，每次在递归之前，**做选择**，在这种方案结束后，我们需要**撤销选择**，这样子的话，就不会影响同一层决策树的其他选择。



举个例子，在走迷宫这类题型中，我们需要不断的去搜索，去试探答案，这个过程就是一个回溯算法的过程，每次要走下一个格子的时候，我们需要先将这个格子**做个标记**，代表这个格子已经走过，然后在往后继续搜索...

当这个方案不合理的时候，我们是不是需要将之前标记的格子清除标记呢？仔细想一想的话，这样子是非常合理的，在当前方案行不通的时候，我们要将这个**步骤撤销掉**。



对于以上的基础知识，有了一定了解，接下来我们就通过这么基础知识来解决问题。



-----------





## 怎么样写回溯



做一些题目后，对回溯算法有初步认识后，我觉得可以参考下面的步骤来刻意练习👇



- 首先画出递归树，找到状态变量（这里可以理解成回溯函数参数）。
- 确定递归出口，一般根据具体题目条件而言。
- 找准选择列表（一般而言与函数参数有关）。
- 剪枝，对于一些情况而言，可以适当剪枝。
- 做出选择，递归调用，进入下一层。
- 撤销选择。



我觉得这个对回溯算法的总结，是挺不错的，可以借鉴下。





---------------





## 2个例子

接下来，我们通过三个题目作为例子，来看看怎么利用分治的思想来解决问题👇





### [最大子序和⭐](https://leetcode-cn.com/problems/maximum-subarray/)



> 链接：[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)



给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:



> 输入: [-2,1,-3,4,-1,2,1,-5,4]
> 输出: 6
>
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。



> 进阶:
>
> 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



------

首先，我们看看能不能以O(n)复杂度解决这个问题，其实仔细想一想的话，我们可以通过一个简单





更多得是，我们这题尝试一下用分治法来解决这题。对于一个数组的最大子序和，它对答案的贡献，只能是以下几种情况👇

- 出现在左半边
- 出现在右半边
- 出现在中间，穿过中间。



那么我们是不是可以递归处理呢，对于出现在左边和出现在右边的答案，我们可以把它们当作是一种情况，然后递归去处理，当然了递归的出口，很显然，当递归的数组的长度为1时，我们需要递归结束。



对于出现在中间答案的情况，我们可以通过计算来算出答案，所以思路理清楚， 接下来，我们看如何写👇







[代码点这里☑️](https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-%E5%AD%97%E6%AF%8D%E5%85%A8%E6%8E%92%E5%88%97.js)

------





### [搜索二维矩阵 II🐍⭐⭐](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)



> 链接：[搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)



编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
示例:

现有矩阵 matrix 如下：



> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]



给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`。



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



------



这题的题目很清晰👉矩阵的每行从左到右是升序， 每列从上到下也是升序，在矩阵中查找某个数。

根据给定的数据，我们其实就明白，在一维数组中，我们可以利用二分的思路，去快速查找，那么我们其实可以利用二分的思路来完成这题。

当然了，我们有一个更加简单的思路下

- 维护两个指针（row,col),找到目标元素时，我们就放回true
- 当指向当前的元素值小于target时，我们就col++，向上移动一行。
- 如果当前的值大于当前的target，我们就row--，向左移动一列。
- 知道col > 矩阵的行，或者row < 0时，我们直接return false，表示不存在。



根据以上的伪代码，我们基本上就能解出这个题目👇

![二维矩阵求值](C:\Users\litiantian03\Desktop\Blog\images\算法\分治法\二位矩阵求值.png)







[代码点这里☑️](https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/leetcode-%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%B1%82%E5%80%BC.js)



------





题目是做不完的，做完这些题目后，希望你能找出回溯算法的规律，能对它有更加深入的理解~，接下来准备了些题集，希望对你们有帮助~







## 进阶题目汇总



以下是我在网上看到一套不错的回溯算法题集，如果你还在刻意找的话，可以看看这里。



| 类型       | 题目链接                                                     |
| ---------- | ------------------------------------------------------------ |
| 子集，组合 | [子集](https://leetcode-cn.com/problems/subsets/)、[子集 II](https://leetcode-cn.com/problems/subsets-ii/)、[组合](https://leetcode-cn.com/problems/combinations/)、[组合总和](https://leetcode-cn.com/problems/combination-sum/)、[组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/) |
| 全排列     | [全排列](https://leetcode-cn.com/problems/permutations/)、[全排列 II](https://leetcode-cn.com/problems/permutations-ii/)、[字符串的全排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)、[字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/) |
| 搜索       | [解数独](https://leetcode-cn.com/problems/sudoku-solver/)、[单词搜索](https://leetcode-cn.com/problems/word-search/)、[N皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)、[分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)、[二进制手表](https://leetcode-cn.com/problems/binary-watch/) |





------------





## ❤️ 感谢大家

如果你觉得这篇内容对你挺有有帮助的话：

1. 点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）
2. 关注公众号**前端UpUp**，联系作者，我们一起学习一起进步。
3. 觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）： 
   - [「算法与数据结构」一张脑图带你看动态规划算法之美](https://juejin.im/post/6872115031501340679)（370+👍）
   - [「算法与数据结构」DFS和BFS算法之美](https://juejin.im/post/6861376131615227912)(240+👍)
   - [「算法与数据结构」梳理6大排序算法](https://juejin.im/post/6856546833025237006)(220+👍)
   - [「算法与数据结构」带你看哈希算法之美(210+👍)](https://juejin.im/post/6874708801208254478)




