

## 前言



最近好多事情，最近前端分享会也如期而至，有幸这次分享会，轮到我分享，分享的主题是关于算法的，正好周末有时间，做个总结吧。



这次想分享的就是**算法与数据结构**，刷了一段时间题目，逛了逛LeetCode，看了很多关于这个方面的文章，有所感悟，准备做个记录。



当你想花时间去了解学习一件对你来说，很苦难的事情的时候，我们需要明确目标，学习它的意义，它有什么用，对你有哪方面帮助。



如何说服自己呢，我个人建议，多看看鸡汤，看多了，自然有动力了。。。

升职加薪必备，对以后成长有所帮助，嗯，加薪，加薪，加薪。

还有一个原因就是：数据结构与算法能力的考核在以 BAT 为代表的国内大厂，一直以来就很重视，为了进大厂～



那么问题来了，为什么要进大厂呢⬇️

> 年轻时候去大厂的目标，是为了避免，【你得顿悟，是别人的基本功】



嗯，闲聊就止步于此，接下来开始吧～





站在巨人肩膀上，学起来就很轻松了， 这里我是参考网上的算法刷题路线，可以参考一下～



![](..\..\Blog\images\算法\算法与数据结构总结-1.png)



接下来，我们就根据这个脑图来梳理一遍吧~



## 排序算法

这应该是面试最常考，最核心的算法。如果你能把排序算法理解的很透彻的话，接下来的其他算法也是一样的旁敲侧击。

当时我梳理得是常见的6个排序算法：

- [冒泡排序](https://juejin.cn/post/6856546833025237006#heading-1)
- [计数排序](https://juejin.cn/post/6856546833025237006#heading-5)
- [快速排序](https://juejin.cn/post/6856546833025237006#heading-9)
- [归并排序](https://juejin.cn/post/6856546833025237006#heading-13)
- [插入排序](https://juejin.cn/post/6856546833025237006#heading-17)
- [选择排序](https://juejin.cn/post/6856546833025237006#heading-21)



在此之前，我也写过一篇排序算法的文章，个人觉得言简意赅，可以看看[「算法与数据结构」梳理6大排序算法](https://juejin.cn/post/6856546833025237006)

有时候，面试官喜欢会问冒泡排序和插入排序，基本上这些都是考察你的基础知识，并且看看你能不能快速地写出没有bug的代码。

又比如，当面试官问你归并排序、快速排序和拓扑排序等的时候，这个时候考察的是你平时对算法得积累，所以有必要做个总结。



我们拿**归并排序**来举例子，我们应该如何表达清楚呢？首先，我们应该把这个它的思路说清楚：

归并排序的核心思想就是分治，它将一个复杂的问题分成两个或者多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。**归并排序**将分治的思想体现得淋漓尽致。



当你向面试官理清楚这个思路时，面试官心里就有底了，他会想，嘿，这个小伙子不错！那你接下来都有底气了！



有了思想，那么实现起来就不难了:



> 一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序。
>
> 排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。



贴一份之前的代码：

```js
const merge = (left, right) => { // 合并数组

    let result = []
    // 使用shift()方法偷个懒,删除第一个元素,并且返回该值
    while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift())
        } else {
            result.push(right.shift())
        }
    }
    while (left.length) {
        result.push(left.shift())
    }

    while (right.length) {
        result.push(right.shift())
    }
    return result
}

let mergeSort = function (arr) {
    if (arr.length <= 1)
        return arr
    let mid = Math.floor(arr.length / 2)
    // 拆分数组
    let left = arr.slice(0, mid),
        right = arr.slice(mid);
    let mergeLeftArray = mergeSort(left),
        mergeRightArray = mergeSort(right)
    return merge(mergeLeftArray, mergeRightArray)
}

// let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2]
// console.log(mergeSort(arr))
```



对于这部分的算法而言，可以围绕从**解题思路**-->>**实现过程**-->>**代码实现**。 基本上以这三步来实现的话，掌握常见的排序算法完成是没有问题的。

那么这部分就暂时梳理到这里吧。





## 动态规划

动态规划难，可以说是很多面试者也是我最怕的部分，尤其是面试的时候，怕面试官考这个算法了。遇到没有做过的题目，这个时候，能否写出状态转移方程是十分重要的。接下来我们聊一聊这个专题吧。

首先，强烈推荐我之前分析这个专题如何准备的： [「算法与数据结构」一张脑图带你看动态规划算法之美](https://juejin.cn/post/6872115031501340679)

如果从点赞角度来看，可以说，是我写算法以来，得到大家肯定最多的一次了，可以看看，不过这里也会涵盖部分。

如何学动态规划，从哪里入手，应该这么去做，这么去刷题，肯定是很多初学者一开始就会遇到的问题。

- 概念
- 动态规划解决了什么问题
- 动态规划解题的步骤
- 如何高效率刷dp专题



首先，你得了解动态规划是什么，它的思想是什么，定义又是啥。这里引入维基百科对它的定义：

> Wikipedia 定义：它既是一种数学优化的方法，同时也是编程的方法。

当然了，看完这段话，我们肯定对它不了解的，我们可以翻译一下，首先它可以算是一种优化的手段，优化一些重复子问题的操作，将很多重叠子问题通过编程的方式来解决，比如**记忆划搜索**。 又比如，如果一个原问题，可以拆分成很多子问题，它们之间没有任何后续性，当前的决策对后续没有影响的话，每个子问题的最优解，就可以组合成原问题的最优解了。



当然了，对于动态规划每个人理解是不同的，对于应用到具体的场景中，需要我们都去用多维度的状态去表述它的含义，这里也就是状态转移方程的含义所在。

嗯，那么动态规划解决了什么问题呢，很显然，对于重复性问题来说，它可以很好的解决，那么从某个维度上来看，它可以优化一个算法的时间复杂度，也就是通常意义上的，拿空间来换取时间的操作。



**动态规划解题步骤**： 这个应该就是实际落地的操作，需要我们去通过大量的题目来完成，具体我们需要怎么做呢？

解题思路，三大步骤👇

1. **状态定义**
2. **列出状态转移方程**
3. **初始化状态**



[「算法与数据结构」一张脑图带你看动态规划算法之美](https://juejin.cn/post/6872115031501340679)强烈推荐这篇问题，里面讲的很清楚了。



**如何高效率刷dp专题**：首先，你得找到对应的dp专题，这里的话，我帮你准备好了，接下来我说一下我是怎么刷leetcode上面的题目的。

一般而言，刷完中等的leetcode上的dp专题，基本上可以满足要求了。那么对于中等的dp题目，很多时候，我是写不吃来的，那我应该如何去做呢？

- 首先，我先看题解，把它的状态转移方程写下来，仔细的品味一下，它这么定义，解决了我之前的什么难点，为啥我是没有想到的。
- 然后，看完之后，尝试按照这个题解思路，我自己能不能单独实现呢？
- 如果不能的话，就照着它的代码，写一遍，多看看状态转移方程是如何写的，把这个题目收藏起来。
- 等到下次，或者是隔天，再来看一遍题目，然后看看能不能单独完成，如果不能，第三天再这么操作。



还有，我个人建议，刷dp的话，最好从易到难，这样子自己也会有信心，也不会再去畏惧它。



### 进阶题目汇总

以下是我收集的部分题目，希望对你们有帮助。

#### 简单

- [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
- [打家劫舍](https://leetcode-cn.com/problems/house-robber/)
- [使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)
- [连续数列](https://leetcode-cn.com/problems/contiguous-sequence-lcci/)
- [三步问题](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

------

#### 中等

- [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)
- [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
- [打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)
- [不同路径](https://leetcode-cn.com/problems/unique-paths/)
- [不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)
- [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

------

#### 困难

- [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
- [买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
- [青蛙过河](https://leetcode-cn.com/problems/frog-jump/)
- [单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)
- [最大子矩阵](https://leetcode-cn.com/problems/max-submatrix-lcci/)



## 搜索算法

这部分也是尤其重要的，那么重点学习深度优先搜索算法（简称为 DFS）和广度优先搜索算法（简称为 BFS）。

我翻了翻我的博客，恰好有一篇类似的问题，大家可以看看**「算法与数据结构」DFS和BFS算法之美**。

不过，我看了一下，我当时写得时候，有点粗糙，很多基本的概念都没有讲明白，所以可能适合一些对这部分有基础的小伙伴。



在这里推荐一个有趣的题目：

[穿过迷宫的最少移动次数](https://leetcode-cn.com/problems/minimum-moves-to-reach-target-with-rotations/)

如果你也遇到过迷宫类似的问题，就可以考虑搜索算法了，从我个人的角度来说，它的思路其实就是模拟人的思路，每次走到一个路口的时候，我可以走哪里，我之前走过的路，怎么确保，接下来是不能走的，这里需要在编程的角度，如何去实现呢？



这里说一说我的经验，对于刚刚提到的题目而言，我盲猜使用BFS，题目做多了，自然就会有心得，对于BFS和DFS而言，做了两个类似的题目，会发现，原来搜索算法也是有迹可循，也是存在某些套路的。



给些建议：

一开始可能做的时候，抓不到头脑，感觉不太理解这个思路，



### 进阶题目汇总

这个专题想进阶，就刷我下面提供的题目吧👇

### DFS

- #### [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

- #### [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

- #### [朋友圈](https://leetcode-cn.com/problems/friend-circles/)

- #### [找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)

- #### [矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

- #### [扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

- #### [单词接龙](https://leetcode-cn.com/problems/word-ladder/)

### BFS

- #### [N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

- #### [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

- #### [最小高度树](https://leetcode-cn.com/problems/minimum-height-trees/)

- #### [扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

------

希望本文能帮助你理解一点DFS，BFS。它的套路是哪些，该何如去写，希望对你是抛砖引玉，加油，UpUpUp。





## 部分大纲



- 基本数据结构
- 高级数据结构
- 基本算法


首先，我们得知道，掌握基本的数据还是很有必要的。











## 基本数据结构

我们都知道数据结构是算法的基石头，对于我们掌握来说，掌握基本的数据结构是很有必要的，所以接下来，这里梳理的内容就是基本的数据结构，以及如何去勾破这个专题。



- 数组
- 字符串
- 链表
- 栈
- 队列
- 双端队列
- 树





## 高级数据结构

所谓的高级数据结构，维护的内容就是不常见，但是使用起来，还是有很多的使用场景的内容，接下来，我们就来看看，他们一一些具体得使用场景吧。


接下来介绍对内容就是常见对高级数据结构，希望对你们有帮助。



- 前缀树（Tire树）
- 线段树
- 树状数组
- 优先队列



所谓对高级数据结构，需要我们做得就是通过我们日常对积累