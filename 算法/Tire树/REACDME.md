## 前言

这次分享的Trie字典树，是数据结构专题中的一个分支，认识了解Trie这种树型数据结构，对构建算法与数据结构知识体系有一定的帮助。





> 我对Trie树的理解：把字符串都串接起来，消灭不必要的存储，利用的就是字符串的公共前缀。



其实对于它的理解，你理解了这句话即可👇

**利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。**





如果你还不了解什么是Trie数据结构的话，或者知道一些，但是对于它具体是如何实现一个简单Trie树时，那么这篇文章可能适合你阅读。





那么围绕以下几个点来展开介绍Trie树👇

- 基本概念
- 基本性质
- 应用场景
- 2个例题

联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。



--------------------





## 基本概念

首先，我们对Trie树得做一些基本的了解。Trie树中文名叫字典树，前缀树等，接下来我就以字典树称呼。

我们来看下维基百科对它的描述吧⬇️



> 在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，**trie**，又称**前缀树**或**字典树**，是一种有序[树](https://zh.wikipedia.org/wiki/树_(数据结构))，用于保存[关联数组](https://zh.wikipedia.org/wiki/关联数组)，其中的键通常是[字符串](https://zh.wikipedia.org/wiki/字符串)。与[二叉查找树](https://zh.wikipedia.org/wiki/二叉查找树)不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的[前缀](https://zh.wikipedia.org/wiki/前缀)，也就是这个节点对应的字符串，而根节点对应[空字符串](https://zh.wikipedia.org/wiki/空字符串)。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。
>



朴实无华的描述，其实我们看一张图就能看明白了~，我在网上找了一张不错的图，具体的出处，这里就不补充了，因为实在找不到原作者~



<img src="..\..\images\算法\Trie\字典树图解1.png" style="zoom:50%;" />



这里需要说明的内容就是，一般而言，**应该是用一个点来表示一个字符**，这里为了更好的说明，所以我就是**用边来描述字符**。



可以发现，这棵字典树用边来代表字母，而**从根结点到树上某一结点的路径就代表了一个字符串**。举个例子， 1→2→6表示的就是字符串 `aba` 。



再比如，`1→4→8`构成的字符串是`ca`，那么如果在往下拓展的话，我们是不是有 `caa`,`cab`，那么他们都会经过`1→4→8`，这些路径，说明他们是有一段公共的前缀，这个前缀的内容就是`ca`，说道这里，我们就知道字典树利用的就是字符串的前缀来解决问题。



那么具体它有哪些性质的话，我们下文介绍一下~



-------------





## 基本性质

对于上述概念有了一定的理解后，我们接下来就看下Trie树的基本性质。



可以根据这个，大体上分成三个点来说👇

1. 根节点不包含字符，除根节点外，每个节点只包含一个字符。
2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符串不相同。



接下来我们可以稍微分析一下，可以结合一个图来看看👇

我们通过拿how,hi,her,hello,so,see这6个字符串构造出来的就是下面图这个样子。

<img src="..\..\images\算法\Trie\图解Trie树.png" style="zoom: 50%;" />

（图片出处不明，网上引用处太多~）



**第一个性质：**

从图中也可以看出，根节点是`/`, 代表的内容也就是空，其他的节点比如，根节点下一个层级，有 `h`和`s`，分别代表的是两个字符。



**第二个性质：**

> 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。



比如`how`表示的就是一个字符串，`hi`,也表示的是一个字符串，可是你会不会好奇，`he`和`hel`为什么不能表示一个字符串呢？

当你想到这里的话，说明你已经看得很仔细，马上就要掌握它了，确实，从图中看，我们会发现有些节点颜色不同，这是因为，我们预定好以这个深色的节点代表当前是一个字符串的结尾，想一想，这样子的作用是啥？



那么实际代码中，我们应该如何去约定或者做个标记呢，其实只要设置一个标记位即可。

比如下面这样子👇

```js
const TrieNode = function () {
  this.next = Object.create(null)
  this.isEnd = false
};
```



当前的isEnd变量就表示当前的节点是不是结束串，当isEnd为True时，表示从根节点开始，到这个字符，所构成的字符串是存在的，是一个完整的字符串。



**第三个性质：**

> 每个节点的所有子节点包含的字符串不相同。



很明显，我们从根节点开始，依次往下走，会发现，每个节点下面的节点是不相同的，所以依次组成的字符串不可能相同。





----------





## 应用场景

对Trie树，有一定了解后，我们就可以看看它有哪些的实际应用场景了。



这里参考的是网上所提供的几个点👇





在搜索引擎中关键词提示，引擎会自动弹出匹配关键词的下拉框，这种应用场景大家应该都很熟悉。

![下拉框](..\..\images\算法\Trie\下拉框.png)



那么应该如何利用一种高效的数据结构存储呢，这里就符合字典树的性质，所以可以利用字典树来构造特定的数据，达到一种更加快速检索的效果。





**字符串检索**

事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率，可以举例子说明情况👇

- 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。
- 给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。



**词频统计**

给定很长的一个串，统计频数出现次数最多情况，举个例子👇

- 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。
- 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。



**字符串最长公共前缀**

到现在，我们应该知道，Trie树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀，所以可以利用这个特点来解决一些前缀问题。

非要举个例子的话，有个例子👇

- 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？







应用场景还是有很多的，剩下的可以自行去探索，接下来，我们通过实际的题目来看看，如何构造字典树吧~



---------------





## 2个例子

接下来，我们通过二个题目作为例子，来看看字典树在实际应用可以解决哪些问题👇



### [词典中最长的单词⭐](https://leetcode-cn.com/problems/longest-word-in-dictionary/)



> 链接：[词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary/)



给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。

若无答案，则返回空字符串。

 

示例 1：

```
输入：
words = ["w","wo","wor","worl", "world"]
输出："world"
解释： 
单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。
```

示例 2：

```
输入：
words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
输出："apple"
解释：
"apply"和"apple"都能由词典中的单词组成。但是"apple"的字典序小于"apply"。
```



提示：
$$
所有输入的字符串都只包含小写字母。
words数组长度范围为[1,1000]。
words[i]的长度范围为[1,30]。
$$


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-word-in-dictionary
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



------



这题无非就是找到一个最长的单词，可以拆分成words数组中某一部分，最暴力的思路就是去枚举每一项，但是这样子的时间复杂度是巨大的， 这个时候，我们是不是可以思考一下，这个问题有哪些地方是共性的呢？

- 没错，就是前缀是相同的，从这点来看，是不是就可以利用这个前缀树，把它数据存储下来
- 然后遍历一遍这课树，只要这颗树只有一个分支，则表示它有解，如果存在两个分支以上的话，则无答案。



复杂度分析
$$
时间复杂度：O(\sum w_i)。w_i 指的是 words[i]的长度。
$$



$$
空间复杂度：O(\sum w_i)，前缀树所使用的空间。
$$
这点应该很好理解，这里就跳过了。



这里的话，我的解法构造字典树，当然了，也有其他的解法，这里就不展开了，可以看下我得代码噢～



![](/Users/lee/Desktop/workspacing/Blog/images/算法/Trie/最长的串.png)





[代码点这里](https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/Tire%E6%A0%91/leetcode-%E5%AD%97%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D.js)☑️

其实你会发现，构造一个Trie树的话，是很消耗空间的，有点空间换时间的意思，所以具体得根据实际的题目来解决问题。





------





### [实现Trie（前缀树）⭐⭐](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)



> 链接：[实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)



实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。

示例:

```
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```


说明:

- 你可以假设所有的输入都是由小写字母 a-z 构成的。
- 保证所有输入均为非空字符串。



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



-----------



这个题目就是典型的写Trie树，对于第一次写这个题目的话，如果没有思路的话，可以尝试先看看别人的代码，看看基本的`套路`在哪里。



话不多说，可以参考这份代码，可以看看如何构造一颗字典树👇





<img src="..\..\images\算法\Trie\leetcode-实现Trie树.png" style="zoom: 50%;" />





[代码点这里☑️](https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/Tire%E6%A0%91/leetcode-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AATrie%E6%A0%91.js)



剩下的删除操作，还有统计字符串出现的频率，可以自己来实现一下，这个基本上不难，画个图，就知道如何实现啦～



------



题目是做不完的，做完这些题目后，希望你能对Trie字典树有所认识，能对它有更加深入的理解~，接下来准备了四道题集，希望对你们有帮助~



[词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary/)

[实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

[单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

[Loading question](https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/)





## ❤️ 感谢大家

如果你觉得这篇内容对你挺有有帮助的话：

1. 点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）
2. 关注公众号**前端UpUp**，联系作者，遇到问题的话，欢迎打扰我，我们一起探讨一起进步。
3. 觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）： 
   - [「算法与数据结构」一张脑图带你看动态规划算法之美](https://juejin.im/post/6872115031501340679)（370+👍）
   - [「算法与数据结构」DFS和BFS算法之美](https://juejin.im/post/6861376131615227912)(240+👍)
   - [「算法与数据结构」梳理6大排序算法](https://juejin.im/post/6856546833025237006)(220+👍)
   - [「算法与数据结构」带你看哈希算法之美(210+👍)](https://juejin.im/post/6874708801208254478)
   - [「算法与数据结构」分治之美(210+👍)](https://juejin.im/post/6885104477297344525)



