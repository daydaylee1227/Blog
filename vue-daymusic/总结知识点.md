## 总结

主要总结Vue-daymusic项目用到的知识点



## day1-页面骨架的开发

### 小小总结：

webpack配置别名:

1. 进入webpack.base.cong.js文件

2. resolve中alias属性添加别名

   ```
   alias: {
         '@': resolve('src'),
         'common': resolve('src/common'),
         'components': resolve('src/components'),
         'base': resolve('src/base'),
         'api': resolve('src/api')
       }
   
   function resolve(dir) {
     return path.join(__dirname, '..', dir)
   } 
   ```

**vue stylus 中使用@import 引入路径问题**

```
<style  lang="stylus">     
//使用相对路径可以正确导入 
@import '../assets/css/index.styl';     
//使用 @路径引入 报错     
@import '@/assets/css/index.styl'; </style>
```

解决方案

```
 @import '~@/assets /css/index.styl'
```

原理：CSS loader 会把把非根路径的url解释为相对路径， 加~前缀才会解释成模块路径。

**组件注册使用**

需要注意的就是组件的驼峰命名，MHeader –>> m-header

```
第一步
import MHeader from 'components/m-header/m-header'
第二步
export default {
  components: {
    MHeader,
    Tab
  }
}
第三步
<m-header></m-header>
```

**router-link** 声明式

tag属性表示渲染成什么标签，默认是a标签

to表示目标路由连接

active-class 默认值: `"router-link-active"` 激活后使用的class类名

**router-view**

渲染路径匹配到的视图组件

**router.push(...) 编程式导航**

**路由**

默认的是hash模式，使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。

如果不想要很丑的 hash，我们可以用路由的 **history 模式**，这种模式充分利用 `history.pushState` API 来完成 URL 跳转而无须重新加载页面。

```
import Vue from 'vue'
import Router from 'vue-router'
Vue.use(Router)  //Vue注册Router
```

**路由使用**

```
import Recommend from '@/components/recommend/recommend'
import Rank from '@/components/rank/rank'
export default new Router({
  routes: [
    {
      path: '/',
      redirect: '/recommend'
    },
    {
      path: '/',
      name: 'Recommend',
      component: Recommend
    },
  ]
})
```

--------





## day2-推荐页面开发

**先下载jsonp包**

```
cnpm install jsonp -S
```

**使用Promise()封装JSONP**

```
// 封装jsonp
import originJsonp from 'jsonp'
export default function JSONP(url, data, option) {
    url += (url.indexOf('?') === -1 ? '&' : '?') + param(data)
    return new Promise((resolve, reject) => {
        originJsonp(url, option,(err, data) => {
            if(!err) {
                resolve(data)
            }else{
                reject(err)
            }
        })
    }) 
}


// 对{}数据经行封装
export function param(data) {
    let url =''
    for(var k in data) {
        let value = data[k] === void 0 ? '' : data[k]
        url += '&'+ k + '=' + encodeURIComponent(value)
    }
    return url ? url.substring(1) : ''
}
```



**给element元素增加某个class**

```
// dom.js
// 判断某个el是否具有className
export function hasClass(el, className){
    let reg = new RegExp('(^\\s)'+ className + '(\\s|$)')
    return reg.test(el.className)
}

export function addClass(el, className){
    if(hasClass(el,className))  return 
    let newClass = el.className.split(' ')
    newClass.push(className)
    el.className = newClass.join(' ')
}

```

**props属性**

```
props: {
      loop: {
        type: Boolean,
        default: true
      },
      autoPlay: {
        type: Boolean,
        default: true
      },
      interval: {
        type: Number,
        default: 4000
      }
    }
```

**标签上的ref属性**

方便获取到某个元素的DOM

```
<div ref = 'slider'></div>
var vue = new Vue({
	// this.$refs.slider --> div DOM元素
})
```

### 轮播图借用第三方插件better-scroll

```
npm install better-scroll -S
```

使用方法👇

```vue
<template>
  <div class="slider" ref="slider">
    <div class="slider-group" ref="sliderGroup">
      <slot></slot>
    </div>
    <div class="dots"></div>
  </div>
</template>

// 实现无限轮播的滚动,以及完成无线轮播的效果
this.slider = new BScroll(this.$refs.slider, {
        scrollX: true,
        scrollY: false,
        momentum: false,
        snap: true,
        snapLoop: this.loop, // 表示轮播
        snapThreshold: 0.3,
        snapSpeed: 400,
});
```

为什么轮播图实现不了无缝轮播，

解决的办法就是减低版本，最新版本不知道为什么使用不了

```
"better-scroll": "^0.1.15"
```



### keep-alive组件

该组件的好处就在于，缓存组件的数据，将数据保存在内存中，效果更加。

不加keep-alive组件的话，每次重新加载的话，会重新去发起数据请求，那么对应的比如reCommend.vue组件会去重新的渲染，mounted也会重新去渲染，在者的话，比如slider也会重新去初始化。

这样子的好处在于将它们的DOM缓存在内存中



**中间件Express**

在最新的webpack配置中，找到webpack.dev.conf.js文件

我们先来看看webpack官方文档下**[点这里](https://webpack.js.org/configuration/dev-server/#devserverbefore)**

**devServer.before**

function (app, server, compiler)

提供在服务器内部在所有其他中间件之前执行自定义中间件的功能。这可以用于定义自定义处理程序，例如：

**webpack.config.js**

```javascript
module.exports = {
  //...
  devServer: {
    before: function(app, server, compiler) {
      app.get('/some/path', function(req, res) {
        res.json({ custom: 'response' });
      });
    }
  }
};
```

所以我们可以根据这个需求，完成我们的中间件。



### scroll组件

了解better-scroll什么时候需要去重新计算，比如屏幕的宽度，视口大小发生改变的话，需要refresh重新计算。比如better-scroll不能滚动的原因是什么？

- 比如scroll组件下有个slider组件，这个组件也是基于better-scroll组件完成的
- slider组件渲染是根据数据来的，所以slider组件什么时候渲染完成是不确定的
- 导致的原因就是scroll组件计算高度准确，采取的办法就是监听事件
- 监听slider组件中的图片加载事件 load， 图片加载完成的话，重新去计算scroll组件，即去refresh



### vue-lazyload图片懒加载

[点这里](https://github.com/hilongjw/vue-lazyload)

```
$ npm i vue-lazyload -S
```

然后就是注册到vue中

```
import Vue from 'vue'
import App from './App.vue'
import VueLazyload from 'vue-lazyload'
Vue.use(VueLazyload)
// or with options
Vue.use(VueLazyload,{
  loading : require('base/loading/loading.gif')
})
//导入loading图片
```

最后通过👇

```
<img width="60" height="60" v-lazy="item.imgurl">
```



### better-scroll与fastclick点击事件冲突

```
<img class="needsclick"  :src="item.picUrl" @load="loadImage">
```

给你需要点击事件的元素设置一个class属性，needsclick，这样子就不会阻止点击事件了





## day3-歌手页面开发









## 优化

### 使用keep-alive组件缓存,起到一定优化。



```
<keep-alive>  
      <!-- 缓存组件,好处在于避免了组件的重新的渲染 -->
    <router-view></router-view>
</keep-alive>
```

### destroyed()生命钩子函数清理定时器

采用的是better-scroll第三方库，最后在该钩子函数的时候，可以去destroyed()

```
destroyed() {
      clearTimeout(this.timer)
    },
```



### 图片懒加载

对于非首屏的图片，我们可以采用图片懒加载的技术，从而实现了减少请求数量。

```
npm i vue-lazyload -S
```

