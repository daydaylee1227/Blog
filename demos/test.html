<DOCTYPE html>
    <html lang="">

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Title Page</title>

        <!-- Bootstrap CSS -->
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
        <style>
            #box {
                width: 500px;
                height: 500px;
                background: #ccc;
                font-size: 40px;
                text-align: center;
                line-height: 500px;
                margin: auto;
            }
        </style>
        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.3/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->
    </head>

    <body>
        <!-- <h1 class="text-center">Hello World</h1> -->

        <ul id="xxx">下面的内容是子元素1
            <li>li内容>>> <span> 这是span内容123</span></li>
            下面的内容是子元素2
            <li>li内容>>> <span> 这是span内容123</span></li>
            下面的内容是子元素3
            <li>li内容>>> <span> 这是span内容123</span></li>
        </ul>

        <script>
            class EventEmitter {
                constructor() {
                    this._events = this._events || new Map();
                }

                addListener(type, fn) {
                    let handle = this._events.get(type);

                    if (!handle) {
                        this._events.set(type, fn);
                    } else if (handle && typeof handle == 'function') {
                        this._events.set(type, [handle, fn]);
                    } else {
                        handle.push(fn);
                    }
                }

                emit(type, ...args) {
                    let handle = this._events.get(type);

                    if (Array.isArray(handle)) {
                        for (let i = 0; i < handle.length; i++) {
                            handle[i].apply(this, args);
                        }
                    } else {
                        handle.apply(this, args);
                    }
                }

                removeListener(type, fn) {
                    let handle = this._events.get(type);

                    if (handle && typeof handle == 'function') {
                        this._events.delete(type);
                    } else {
                        let position = -1;

                        for (let i = 0; i < handle.length; i++) {
                            if (handle[i] == fn) {
                                position = i;
                            }
                        }

                        if (position != -1) {
                            handle.splice(i, 1);
                        }
                    }
                }

                once(type, fn) {
                    function G() {
                        this.removeListener(type, G);
                        fn.apply(this, [...arguments]);
                    }

                    this.addListener(type, G);
                }
            }
            Function.prototype.MYcall = function (context, ...args) {
                // 执行上下文都保证是对象类型，如果不是就是window
                context = Object(context) || window;
                // 创建一个额外的变量当做context的属性
                const fn = Symbol();
                // 给这个fn属性赋值为当前的函数
                context[fn] = this;
                // 执行函数把...args传入
                const result = context[fn](...args);
                // 删除使用过的fn属性
                delete context[fn];
                // 返回函数执行结果
                return result;
            };


            // 实现call
            Function.prototype.mycall = function () {
                let [thisArg, ...args] = [...arguments]
                thisArg = Object(thisArg) || window
                let fn = Symbol()
                thisArg[fn] = this
                let result = thisArg[fn](...args)
                delete thisArg[fn]
                return result
            }
            // 实现apply
            Function.prototype.myapply = function () {
                let [thisArg, args] = [...arguments];
                thisArg = Object(thisArg)
                let fn = Symbol()
                thisArg[fn] = this;
                let result = thisArg[fn](...args);
                delete thisArg.fn;
                return result;
            }

            let cc = {
                a: 1
            }

            function demo(x1, x2) {
                console.log(typeof this, this.a, this)
                console.log(x1, x2)
            }
            demo.apply(cc, [2, 3])
            demo.myapply(cc, [2, 3])
            demo.call(cc,33,44)
            demo.mycall(cc,33,44)
            // function debounce(fn, delay) {
            //     let timer = null
            //     return function (...args) {
            //         let context = this
            //         if (timer) clearTimeout(timer)
            //         timer = setTimeout(function () {
            //             fn.apply(context, args)
            //         }, delay)
            //     }
            // }
            // const box = document.getElementById('box')
            // let debounceShow = throttle(function ff(e) {
            //     box.innerHTML = `${e.clientX}, ${e.clientY}`
            // }, 1000)
            // box.onmousedown = debounceShow;
            // // box.onmousemove = function (e) {
            // //     box.innerHTML = `${e.clientX}, ${e.clientY}`
            // // }

            // function demo1(...arg) {
            //     console.log(arg)
            // }
            // window.onresize = debounce(() => {
            //     console.log(222)
            // }, 500)


            // function throttle(fn, delay) {
            //     let last = 0,
            //         timer = null;
            //     return function (...args) {
            //         let context = this,
            //             now = new Date();
            //         if (now - last < delay) {
            //             clearTimeout(timer)
            //             timer = setTimeout(() => {
            //                 last = now
            //                 fn.apply(context, args)
            //             }, delay);
            //         } else {
            //             last = now
            //             fn.apply(context, args)
            //         }
            //     }
            // }

            // var END = Math.pow(2, 53);
            // var START = END - 100;
            // var count = 0;
            // for (var i = START; i <= END; i++) {
            //     count++;
            // }
            // console.log(count);

            // function throttle(fn, delay) {
            //     let flag = true,
            //         timer = null;
            //     return function (...args) {
            //         let context = this;
            //         if (!flag) return;
            //         flag = false;
            //         clearTimeout(timer)
            //         timer = setTimeout(() => {
            //             fn.apply(context, args);
            //             flag = true;
            //         }, delay);
            //     };
            // };
        </script>
        <!-- <script>
        class ListNode {
            constructor(val) {
                this.val = val;
                this.next = null;
            }
        }
        //单链表插入、删除、查找
        class LinkedList {
            constructor(val) {
                val = val === undefined ? 'head' : val;
                this.head = new ListNode(val)
            }

            // 找val值节点，没有找到返回-1
            findByVal(val) {
                let current = this.head
                while (current !== null && current.val !== val) {
                    current = current.next
                }
                return current ? current : -1
            }

            // 插入节点,在值为val后面插入
            insert(newVal, val) {
                let current = this.findByVal(val)
                if (current === -1) return false
                let newNode = new ListNode(newVal)
                newNode.next = current.next
                current.next = newNode
            }

            // 获取值为nodeVal的前一个节点,找不到为-1,参数是val
            // 适用于链表中无重复节点
            findNodePreByVal(nodeVal) {
                let current = this.head;
                while (current.next !== null && current.next.val !== nodeVal)
                    current = current.next
                return current !== null ? current : -1
            }

            // 根据index查找当前节点, 参数为index
            // 可以作为比较链表是否有重复节点

            findByIndex(index) {
                let current = this.head,
                    pos = 1
                while (current.next !== null && pos !== index) {
                    current = current.next
                    pos++
                }

                return (current && pos === index) ? current : -1
            }

            // 删除某一个节点,删除失败放回false
            remove(nodeVal) {
                if (nodeVal === 'head') return false
                let needRemoveNode = this.findByVal(nodeVal)
                if (needRemoveNode === -1) return false
                let preveNode = this.findNodePreByVal(nodeVal)

                preveNode.next = needRemoveNode.next
            }


            //遍历节点

            disPlay() {
                let res = new Array()
                let current = this.head
                while (current !== null) {
                    res.push(current.val)
                    current = current.next
                }
                return res
            }

            // 在链表末尾插入一个新的节点
            push(nodeVal) {
                let current = this.head
                let node = new ListNode(nodeVal)
                while (current.next !== null)
                    current = current.next
                current.next = node
            }
            // 在头部插入
            frontPush(nodeVal) {
                let newNode = new ListNode(nodeVal)
                this.insert(nodeVal, 'head')
            }
        }
        let demo = new LinkedList() // LinkedList {head: ListNode}
        // console.log((demo.disPlay())) 
        demo.push('1232')
        demo.insert(123, 'head');
        demo.push('last value')
        demo.frontPush('start')
        demo.remove('head')
        // demo.remove('last value')
        // console.log(demo.remove('head'))
        // demo.push('2132')
        // demo.insert('不存在的值', '插入失败') //return -1
        console.log(demo.findByIndex(1))
        console.log((demo.disPlay()))
    </script> -->
    </body>

    </html>