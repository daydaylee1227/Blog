## 前言

想要成为一名合格的前端工程师，掌握相关浏览器的工作原理是必备的，这样子才会有一个完整知识体系，要是**「能参透浏览器的工作原理，你就能解决80%的前端难题」**。



这算是浏览器工作原理篇的查缺补漏，对于一些没有涉及到的知识点，准备梳理梳理，也正好回顾之前梳理的内容。



**阅读本文须知，最好看过往期两篇**

> [[1.2W字👍]写给女友的秘籍-浏览器工作原理（上）篇](https://juejin.im/post/5f007d32f265da22b64936bf)
>
> [[1.1W字]写给女友的秘籍-浏览器工作原理（渲染流程）篇](https://juejin.im/post/5f05d12a5188252e8406e37b)



**「读完这一期内容，你将收获」**

- 前端性能优化的底层逻辑；
- 浏览器页面渲染的核心流程
- JavaScript 运行机制解析
- 浏览器网络及安全机制解析

小声说：欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程👊



---



**接下来以问题形式展开梳理**





## 常见的浏览器内核有哪些?

| 浏览器/RunTime | 内核（渲染引擎） |                       JavaScript 引擎                        |
| :------------: | :--------------: | :----------------------------------------------------------: |
|     Chrome     |  webkit->blink   |                              V8                              |
|    FireFox     |      Gecko       |                         SpiderMonkey                         |
|     Safari     |      Webkit      |                        JavaScriptCore                        |
|      Edge      |     EdgeHTML     |                    Chakra(for JavaScript)                    |
|       IE       |     Trident      |                    JScript（IE3.0-IE8.0）                    |
|     Opera      |  Presto->blink   | Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |
|    Node.js     |        -         |                              V8                              |



--------



## 浏览器的主要组成部分是什么？

1. **用户界面** - 包括地址栏、前进/后退按钮、书签菜单等。
2. **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。
3. **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
4. **网络** - 用于网络调用，比如 HTTP 请求。
5. **用户界面后端** -用于绘制基本的窗口小部件，比如组合框和窗口。
6. **JavaScript 解释器**- 用于解析和执行 JavaScript 代码。
7. **数据存储** - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。

------------



## 1. 为什么JavaScript是单线程的，与异步冲突吗

补充：JS中其实是没有线程概念的，所谓的单线程也只是相对于多线程而言。JS的设计初衷就没有考虑这些，针对JS这种不具备并行任务处理的特性，我们称之为“单线程”。

JS的单线程是指一个浏览器进程中只有一个JS的执行线程，同一时刻内只会有一段代码在执行。



举个通俗例子，假设JS支持多线程操作的话，JS可以操作DOM，那么一个线程在删除DOM，另外一个线程就在获取DOM数据，这样子明显不合理，这算是证明之一。



来看段代码👇

```js
function foo() {
    console.log("first");
    setTimeout(( function(){
        console.log( 'second' );
    }),5);
}
 
for (var i = 0; i < 1000000; i++) {
    foo();
}

```

打印结果就是首先是很多个first,然后再是second。

异步机制是浏览器的两个或以上常驻线程共同完成的，举个例子，比如异步请求由两个常驻线程，JS执行线程和事件触发线程共同完成的。

- JS执行线程发起异步请求（浏览器会开启一个HTTP请求线程来执行请求，这时JS的任务完成，继续执行线程队列中剩下任务）
- 然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待JS处理

再比如定时器触发(settimeout和setinterval) 是由**浏览器的定时器线程**执行的定时计数，然后在定时时间把定时处理函数的执行请求插入到JS执行队列的尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。

所以这么说，JS单线程与异步更多是浏览器行为，之间不冲突。



-------



## 2. CSS加载会造成阻塞吗

先给出结论

- `CSS`不会阻塞`DOM`解析，但会阻塞`DOM`渲染。
- `CSS`会阻塞JS执行，并不会阻塞JS文件下载

先讲一讲CSSOM作用

- 第一个是提供给 JavaScript 操作样式表的能力
- 第二个是为布局树的合成提供基础的样式信息
- 这个 CSSOM 体现在 DOM 中就是document.styleSheets。



由之前讲过的浏览器渲染流程我们可以看出：

DOM 和 CSSOM通常是并行构建的，所以**CSS 加载不会阻塞 DOM 的解析**。

然而由于Render Tree 是依赖DOM Tree和 CSSOM Tree的，所以它必须等到两者都加载完毕后，完成相应的构建，才开始渲染，因此，**CSS加载会阻塞DOM渲染**。

由于 JavaScript 是可操纵 DOM 和 css 样式 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果,浏览器设置 **GUI 渲染线程与 JavaScript 引擎为互斥**的关系。



有个需要注意的点就是：

**有时候JS需要等到CSS的下载，这是为什么呢？**



仔细思考一下，其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等`CSS`控制的属性，浏览器是需要计算的，也就是依赖于`CSS`。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行`JS`。



JS文件下载和CSS文件下载是并行的，有时候CSS文件很大，所以JS需要等待。



因此,样式表会在后面的 js 执行前先加载执行完毕,所以**css 会阻塞后面 js 的执行**。

--------



## 3. 为什么JS会阻塞页面加载

先给出结论👇

- **JS阻塞DOM解析**，也就会阻塞页面

这也是为什么说JS文件放在最下面的原因，那为什么会阻塞DOM解析呢

你可以这样子理解：

> 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。
>
> 因此为了防止渲染出现不可预期的结果,浏览器设置 **GUI 渲染线程与 JavaScript 引擎为互斥**的关系。
>
> 当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。
>
> 当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行。
>
> 因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉。



另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码



-----------



## 4. defer 和 async 的区别 ?

- 两者都是异步去加载外部JS文件，不会阻塞DOM解析
- Async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，标记为async的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 (即没有**src**属性的脚本）。
- defer是在JS加载完成后，整个文档解析完成后，触发 `DOMContentLoaded` 事件前执行，如果缺少 `src` 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用



--------





## 5. DOMContentLoaded 与 load 的区别 ?

- DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。
- onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。

那么也就是先DOMContentLoaded -> load,那么在Jquery中，使用$(document).read(callback)监听的就是DOMContentLoaded事件，$(document).load(callback)监听的就是load事件。

那我们可以聊一聊它们与async和defer区别

> 带async的脚本一定会在load事件之前执行，可能会在DOMContentLoaded之前或之后执行。

- 情况1： HTML 还没有被解析完的时候，async脚本已经加载完了，那么 HTML 停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件
- 情况2： HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件





> 如果 script 标签中包含 defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。

- 情况1：HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件
- 情况2：HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件



--------



## 6. 为什么CSS动画比JavaScript高效







## 能不能实现事件防抖和节流

### 函数节流(throttle)

> 节流的意思是让函数有节制地执行，而不是毫无节制的触发一次就执行一次。什么叫有节制呢？就是在一段时间内，只执行一次。
>
> 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

抓取一个关键的点：就是执行的时机。要做到控制执行的时机，我们可以通过**一个开关**，与定时器setTimeout结合完成。

```js
		function throttle(fn, delay) {
            let flag = true,
                timer = null;
            return function (...args) {
                let context = this;
                if (!flag) return;
                flag = false;
                clearTimeout(timer)
                timer = setTimeout(() => {
                    fn.apply(context, args);
                    flag = true;
                }, delay);
            };
        };
```



### 函数防抖(debounce)

> 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

核心思想：每次事件触发都会删除原有定时器，建立新的定时器。通俗意思就是反复触发函数，只认最后一次，从最后一次开始计时。

代码：

```js
		function debounce(fn, delay) {
            let timer = null
            return function (...args) {
                let context = this
                if(timer)   clearTimeout(timer)
                timer = setTimeout(function() {
                    fn.apply(context, args)
                },delay)
            }
        }
```



### 如何使用 debounce 和 throttle 以及常见的坑

自己造一个 debounce / throttle 的轮子看起来多么诱人，或者随便找个博文复制过来。**我是建议直接使用 underscore 或 Lodash** 。如果仅需要 `_.debounce` 和 `_.throttle` 方法，可以使用 Lodash 的自定义构建工具，生成一个 2KB 的压缩库。使用以下的简单命令即可：

```markdown
npm i -g lodash-cli
npm i -g lodash-clilodash-cli include=debounce,throttle
```

常见的坑是，不止一次地调用 `_.debounce` 方法：

```js
// 错误
$(window).on('scroll', function() {
   _.debounce(doSomething, 300); 
});
// 正确
$(window).on('scroll', _.debounce(doSomething, 200));

```

debounce 方法保存到一个变量以后，就可以用它的私有方法 `debounced_version.cancel()`，lodash 和 underscore.js 都有效。

```js
let debounced_version = _.debounce(doSomething, 200);

$(window).on('scroll', debounced_version);


// 如果需要的话debounced_version.cancel();
```





### 适合应用场景

防抖

- search搜索，用户不断输入值时，用防抖来节约Ajax请求,也就是输入框事件。
- window触发resize时，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次



节流

- 鼠标的点击事件，比如mousedown只触发一次
- 监听滚动事件，比如是否滑到底部自动加载更多，用throttle判断
- 比如游戏中发射子弹的频率(1秒发射一颗)



----------



## 谈一谈你对requestAnimationFrame（rAF）理解



正好跟节流有点关系，有点相似处，就准备梳理一下这个知识点。

### **高性能动画是什么，那它衡量的标准是什么呢？**

动画帧率可以作为衡量标准，一般来说画面在 60fps 的帧率下效果比较好。

换算一下就是，每一帧要在 16.7ms (16.7 = 1000/60) 内完成渲染。

我们来看看MDN对它的解释吧👇

> window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。*-- MDN*

当我们调用这个函数的时候，我们告诉它需要做两件事：

1. 我们需要新的一帧；
2. 当你渲染新的一帧时需要执行我传给你的回调函数



### rAF与 setTimeout 相比

rAF(requestAnimationFrame) 最大的优势是**由系统来决定回调函数的执行时机**。

具体一点讲就是，系统每次绘制之前会主动调用 rAF 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。

> 换句话说就是，rAF 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次(上一个知识点刚刚梳理完**函数节流**)，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

另外它可以自动调节频率。如果callback工作太多无法在一帧内完成会自动降低为30fps。虽然降低了，但总比掉帧好。

与setTimeout动画对比的话，有以下几点优势

- 当页面隐藏或者最小化时，setTimeout仍然在后台执行动画，此时页面不可见或者是不可用状态，动画刷新没有意义，而言浪费CPU。
- rAF不一样，当页面处理未激活的状态时，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的rAF也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。



### 什么时候调用呢

规范中似乎是这么去定义的：

- 在重新渲染前调用。
- 很可能在宏任务之后不去调用

这样子分析的话，似乎很合理嘛，为什么要在重新渲染前去调用呢？因为rAF作为官方推荐的一种做流畅动画所应该使用的API，做动画不可避免的去操作DOM，而如果是在渲染后去修改DOM的话，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这样子似乎不合理。

> `rAF`在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。



至于宏任务，微任务，这可以说起来就要展开篇幅了，暂时不在这里梳理了。



### rAF与节流相比

跟 `_.throttle(dosomething, 16)` 等价。它是高保真的，如果追求更好的精确度的话，可以用浏览器原生的 API 。

可以使用 rAF API 替换 throttle 方法，考虑一下优缺点：



优点

- 动画保持 60fps（每一帧 16 ms），浏览器内部决定渲染的最佳时机
- 简洁标准的 API，后期维护成本低

缺点

- 动画的开始/取消需要开发者自己控制，不像 ‘.debounce’ 或 ‘.throttle’由函数内部处理。
- 浏览器标签未激活时，一切都不会执行。
- 尽管所有的现代浏览器[都支持 rAF](http://caniuse.com/#feat=requestanimationframe) ，IE9，Opera Mini 和 老的 Android 还是[需要打补丁](http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/)。
- Node.js 不支持，无法在服务器端用于文件系统事件。



根据经验，如果 JavaScript 方法需要绘制或者直接改变属性，我会选择 `requestAnimationFrame`，只要涉及到重新计算元素位置，就可以使用它。



涉及到 AJAX 请求，添加/移除 class （可以触发 CSS 动画），我会选择 `_.debounce` 或者 `_.throttle` ，可以设置更低的执行频率（例子中的200ms 换成16ms）。







------





## 能不能实现图片的懒加载



```markdown
页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth (包括边线的宽);
网页可见区域高： document.body.offsetHeight (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
```



关于scrollTop,offsetTop,scrollLeft,offsetLeft用法介绍，[点这里](https://i.jakeyu.top/2016/09/04/scrollTop-offsetTop-scrollLeft-offsetLeft/)

#### **原理思路**

1. 拿到所以的图片`img dom`
2. 重点是第二步，判断当前图片是否到了可视区范围内
3. 到了可视区的高度以后，就将img的data-src属性设置给src
4. 绑定window的`scroll`事件

当然了，为了用户的体验更加，默认的情况下，设置一个**占位图**

本次测试代码

CSS代码👇

```css
<style>
        img{
            display: block;
            height: 320px;
            margin-top: 20px;
            margin: 10px auto;
        }
</style>
```

HTML👇

```
<img src="default.png" data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1595328889118&di=1665d7e122bc96be92d0f3e1b2f5e302&imgtype=0&src=http%3A%2F%2Fwork.361ser.com%2FContent%2Fueditor%2Fnet%2Fupload%2Fimage%2F20171014%2F6364359407281350179759303.jpg" />
```



#### 第一种方式

**clientHeight-scrollTop-offsetTop**

直接上我运行的代码👇

```js
let Img = document.getElementsByTagName("img"),
            len = Img.length,
            count = 0; 
        function lazyLoad () {
            let viewH = document.body.clientHeight, //可见区域高度
                scrollTop = document.body.scrollTop; //滚动条距离顶部高度
            for(let i = count; i < len; i++) {
                if(Img[i].offsetTop < scrollTop + viewH ){
                    if(Img[i].getAttribute('src') === 'default.png'){
                        Img[i].src = Img[i].getAttribute('data-src')
                        count++;
                    }
                }
            }
        }
        function throttle(fn, delay) {
            let flag = true,
                timer = null;
            return function (...args) {
                let context = this;
                if (!flag) return;
                flag = false;
                clearTimeout(timer)
                timer = setTimeout(() => {
                    fn.apply(context, args);
                    flag = true;
                }, delay);
            };
        };
        window.addEventListener('scroll', throttle(lazyLoad,1000))
        
        lazyLoad();  // 首次加载
```



#### 第二种方式

使用 `element.getBoundingClientRect()` API 直接得到 top 值。

代码👇

```js
let Img = document.getElementsByTagName("img"),
            len = Img.length,
            count = 0; 
        function lazyLoad () {
            let viewH = document.body.clientHeight, //可见区域高度
                scrollTop = document.body.scrollTop; //滚动条距离顶部高度
            for(let i = count; i < len; i++) {
                if(Img[i].getBoundingClientRect().top < scrollTop + viewH ){
                    if(Img[i].getAttribute('src') === 'default.png'){
                        Img[i].src = Img[i].getAttribute('data-src')
                        count++;
                    }
                }
            }
        }
        function throttle(fn, delay) {
            let flag = true,
                timer = null;
            return function (...args) {
                let context = this;
                if (!flag) return;
                flag = false;
                clearTimeout(timer)
                timer = setTimeout(() => {
                    fn.apply(context, args);
                    flag = true;
                }, delay);
            };
        };
        window.addEventListener('scroll', throttle(lazyLoad,1000))

        lazyLoad();  // 首次加载 
```



好像也差不多，不知道是不是我写的方式有问题(●'◡'●)，感觉差不多

来看看效果吧，我给这个事件加了一个节流，这样子操作看起来就更好了。

![图片懒加载](C:\Users\DayDay\Desktop\Blog\images\浏览器相关\图片懒加载.gif)







## 说一说你对Cookie localStorage sessionStorage

### Cookie

得扯一下`HTTP是一个无状态的协议`，这里主要指的是HTTP1.x版本，简单的可以理解为即使同一个客户端连续两次发送请求给服务器，服务器也无法识别这个同一个客户端发的请求，导致的问题，比如现实生活中你加入一个商品到购物车，但是因为无法识别同一个客户端，你刷新页面的话就🤭

为了解决 HTTP 无状态导致的问题（HTTP1.x），后来出现了 Cookie。

> Cookie 的存在也不是为了解决通讯协议无状态的问题，只是为了解决客户端与服务端会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。

Cookie存放在本地的好处就在于即使你关闭了浏览器，Cookie 依然可以生效。



#### Cookie设置

怎么去设置呢？简单来说就是👇

1. 客户端发送 HTTP 请求到服务器
2. 当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段
3. 浏览器收到响应后保存下 Cookie
4. 之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。

#### Cookie指令

在下面这张图里我们可以看到 Cookies 相关的一些属性👇

![](C:\Users\DayDay\Desktop\Blog\images\浏览器相关\Cookie.PNG)

这里主要说一些大家可能没有注意的点：

#### **Name/Value**

用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。

#### Expires/Max-Age

Expires 用于设置 Cookie 的过期时间。比如：

```
Set-Cookie: id=aad3fWa; Expires=Wed, 21 May 2020 07:28:00 GMT;
```

- 当 Expires 属性缺省时，表示是会话性 Cookie。
- 像上图 Expires 的值为 Session，表示的就是会话性 Cookie。
- 会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。
- 需要注意的是，有些浏览器提供了会话恢复功能，关闭浏览器，会话期Cookie会保留下来。
- 与会话性 Cookie 相对的是持久性 Cookie，持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。

Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。比如：

```
Set-Cookie: id=a3fWa; Max-Age=604800;
```

假如 Expires 和 Max-Age 都存在，Max-Age 优先级更高。

#### Domain

Domain 指定了 Cookie 可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。

在这里注意的是，不能跨域设置 Cookie

#### Path

Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。比如设置 `Path=/docs`，`/docs/Web/` 下的资源会带 Cookie 首部，`/test` 则不会携带 Cookie 首部。



**Domain 和 Path 标识共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。**

#### Secure属性

标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。

#### HTTPOnly

设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。

#### SameSite

SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。

后面讲CSRF攻击会将讲到，这里过。

这个属性值修改有什么影响呢？

![](C:\Users\DayDay\Desktop\Blog\images\浏览器相关\Samesite.png)

从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。

#### Cookie 的作用

Cookie 主要用于以下三个方面：

1. 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
2. 个性化设置（如用户自定义设置、主题等）
3. 浏览器行为跟踪（如跟踪分析用户行为等）

#### Cookie 的缺点

从大小，安全，增加请求大小。

- 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
- 降低性能，Cookie紧跟着域名，不管域名下的某个地址是否需要这个Cookie，请求都会带上完整的Cookie，请求数量增加，会造成巨大的浪费。
- 安全缺陷，Cookie是以纯文本的形式在浏览器和服务器中传递，很容易被非法用户获取，当HTTPOnly为false时，Cookie信息还可以直接通过JS脚本读取。



### localStorage 和  sessionStorage

在 web 本地存储场景上，cookie 的使用受到种种限制，最关键的就是存储容量太小和数据无法持久化存储。

在 HTML 5 的标准下，出现了 localStorage 和 sessionStorage 供我们使用。





#### 异同点

| 分类           | 生命周期                                                     | 存储容量                                   | 存储位置                                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------ | ------------------------------------------ |
| cookie         | 默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效） | 4KB                                        | 保存在客户端，每次请求时都会带上           |
| localStorage   | 理论上永久有效的，除非主动清除。                             | 4.98MB（不同浏览器情况不同，safari 2.49M） | 保存在客户端，不与服务端交互。节省网络流量 |
| sessionStorage | 仅在当前网页会话下有效，关闭页面或浏览器后会被清除。         | 4.98MB（部分浏览器没有限制）               | 同上                                       |

#### 操作方式

接下来我们来具体看看如何来操作`localStorage`和`sessionStorage`

```
let obj = { name: "TianTianUp", age: 18 };
localStorage.setItem("name", "TianTianUp"); 
localStorage.setItem("info", JSON.stringify(obj));
```

接着进入相同的域名时就能拿到相应的值👇

```
let name = localStorage.getItem("name");
let info = JSON.parse(localStorage.getItem("info"));
```

从这里可以看出，`localStorage`其实存储的都是字符串，如果是存储对象需要调用`JSON`的`stringify`方法，并且用`JSON.parse`来解析成对象。



#### 应用场景

- localStorage 适合持久化缓存数据，比如页面的默认偏好配置，如官网的`logo`，存储`Base64`格式的图片资源等；

- sessionStorage 适合一次性临时数据保存，存储本次浏览信息记录，这样子页面关闭的话，就不需要这些记录了，还有对表单信息进行维护，这样子页面刷新的话，也不会让表单信息丢失。





## 聊一聊浏览器缓存

什么是浏览器缓存，我个人觉得











## 说一说从输入URL到页面呈现发生了什么？









## 谈一谈你对重排和重绘理解

关于重排和重绘，本期文章上个章节渲染篇梳理过了，点下面

[[1.1W字]写给女友的秘籍-浏览器工作原理（渲染流程）篇](https://juejin.im/post/5f05d12a5188252e8406e37b#heading-29)





## 谈一谈跨域，同源策略，以及跨域解决方案

### 什么是跨域

跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。

### 同源策略

同源策略是一个安全策略。所谓的同源,指的是协议,域名,端口相同。

![同源策略](C:\Users\DayDay\Desktop\Blog\images\浏览器相关\同源策略.png)

浏览器处于安全方面的考虑,只允许本域名下的接口交互,不同源的客户端脚本,在没有明确授权的情况下,不能读写对方的资源。

限制了一下行为：

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 JS 对象无法获取
- Ajax请求发送不出去



### 解决方案

#### jsonp跨域



#### postMessage跨域



#### 跨域资源共享 CORS



#### WebSocket协议跨域



#### node代理跨域



#### nginx代理跨域





-----



## 谈一谈你对XSS攻击理解

### 什么是 XSS 攻击

XSS 全称是 `Cross Site Scripting` ,为了与`CSS`区分开来，故简称 `XSS`，翻译过来就是“跨站脚本”。

XSS是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。发展到现在，往HTML文件中中插入恶意代码方式越来越多，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。

注入恶意脚本可以完成这些事情：

1. 窃取Cookie
2. 监听用户行为，比如输入账号密码后之间发给黑客服务器
3. 在网页中生成浮窗广告
4. 修改DOM伪造登入表单



一般的情况下，XSS攻击有三种实现方式

- 存储型 XSS 攻击
- 反射型 XSS 攻击
- 基于 DOM 的 XSS 攻击

#### 存储型 XSS 攻击



![存储型 XSS 攻击](C:\Users\DayDay\Desktop\Blog\images\浏览器相关\存储型XSS.png)

从图上看，存储型 XSS 攻击大致步骤如下：

1. 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
2. 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
3. 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。



比如常见的场景：

在评论区提交一份脚本代码，假设前后端没有做好转义工作，那内容上传到服务器，在页面渲染的时候就会`直接执行`，相当于执行一段未知的JS代码。这就是存储型 XSS 攻击。



#### 反射型 XSS 攻击

反射型 XSS 攻击指的就是恶意脚本作为**网络请求的一部分**，随后网站又把恶意的JavaScript脚本返回给用户，当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。

举个例子:

```
http://TianTianUp.com?query=<script>alert("你受到了XSS攻击")</script>
```

如上，服务器拿到后解析参数query，最后将内容返回给浏览器，浏览器将这些内容作为HTML的一部分解析，发现是Javascript脚本，直接执行，这样子被XSS攻击了。

这也就是反射型名字的由来，将恶意脚本作为参数，通过网络请求，最后经过服务器，在反射到HTML文档中，执行解析。

主要注意的就是，**服务器不会存储这些恶意的脚本，这也算是和存储型XSS攻击的区别吧**。



#### 基于 DOM 的 XSS 攻击

基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，在数据传输的时候劫持网络数据包

常见的劫持手段有：

- WIFI路由器劫持
- 本地恶意软件



### 阻止 XSS 攻击的策略

以上讲述的XSS攻击原理，都有一个共同点：让恶意脚本直接在浏览器执行。

针对三种不同形式的XSS攻击，有以下三种解决办法



#### 对输入脚本进行过滤或转码

对用户输入的信息过滤或者是转码



举个例子👇

<script>alert('你受到XSS攻击了')</script>
转码后👇

```markdown
&lt;script&gt;alert(&#39;你受到XSS攻击了&#39;)&lt;/script&gt;
```

这样的代码在 html 解析的过程中是无法执行的。

当然了对于`<script>`、`<img>`、`<a>`等关键字标签也是可以过来的，效果如下👇

```
   
```

最后什么都没有剩下了



#### 利用 CSP

该安全策略的实现基于一个称作 `Content-Security-Policy `的 [HTTP](https://developer.mozilla.org/en-US/docs/Glossary/HTTP) 首部。

可以移步[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)，有更加规范的解释。我在这里就是梳理一下吧。

CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能👇

- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
- 禁止向第三方域提交数据，这样用户数据也不会外泄；
- 提供上报机制，能帮助我们及时发现 XSS 攻击。
- 禁止执行内联脚本和未授权的脚本；



#### 利用 HttpOnly

由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。这样子的话，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。

通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：

```
set-cookie: NID=189=M8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly
```



### 总结

`XSS` 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为`存储型`、`反射型`和`文档型`。防范的措施包括:

- 对输入内容过滤或者转码，尤其是类似于`<script>`、`<img>`、`<a>`标签
- 利用CSP
- 利用Cookie的HttpOnly属性

除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。



--------------



## 能不能说一说CSRF攻击

### 什么是CSRF攻击呢？

CSRF 英文全称是 `Cross-site request forgery`，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，**CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。**



一般的情况下，点开一个诱导你的链接，黑客会在你不知情的时候做哪些事情呢



#### 1. 自动发起 Get 请求

黑客网页里面可能有一段这样的代码👇

```text
 <img src="http://bank.example/withdraw?amount=10000&for=hacker" > 
```

在受害者访问含有这个img的页面后，浏览器会自动向`http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker`发出一次HTTP请求。

`bank.example`就会收到包含受害者登录信息的一次跨域请求。



#### 2. 自动发起 POST 请求

黑客网页中有一个表单，自动提交的表单👇

```js
 <form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
```

访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。



#### 3. 引诱用户点击链接

这种需要诱导用户去点击链接才会触发，这类的情况比如在论坛中发布照片，照片中嵌入了恶意链接，或者是以广告的形式去诱导，比如：

```text
 <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
  重磅消息！！！
  <a/>
```

点击后，自动发送 get 请求，接下来和`自动发 GET 请求`部分同理。



以上三种情况，就是CSRF攻击原理，跟XSS对比的话，CSRF攻击并不需要将恶意代码注入HTML中，而是跳转新的页面，利用**服务器的验证漏洞**和**用户之前的登录状态**来模拟用户进行操作



### **防护策略**



其实我们可以想到，黑客只能借助受害者的`**cookie**`骗取服务器的信任，但是黑客并不能凭借拿到**cookie**，也看不到 **cookie**的内容。另外，对于服务器返回的结果，由于浏览器**同源策略**的限制，黑客也无法进行解析。

> 这就告诉我们，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行`**CSRF**`的保护。而保护的关键，是 **在请求中放入黑客所不能伪造的信息**



#### 用户操作限制——验证码机制

方法：添加验证码来识别是不是用户主动去发起这个请求，由于一定强度的验证码机器无法识别，因此危险网站不能伪造一个完整的请求。



#### 1. 验证来源站点

在服务器端验证请求来源的站点，由于大量的CSRF攻击来自第三方站点，因此服务器跨域禁止来自第三方站点的请求，主要通过HTTP请求头中的两个Header

- Origin Header
- Referer Header

这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。

服务器可以通过解析这两个Header中的域名，确定请求的来源域。

其中，**Origin**只包含域名信息，而**Referer**包含了`具体`的 URL 路径。

在某些情况下，这两者都是可以伪造的，通过`AJax`中自定义请求头即可，安全性略差。



#### 2. 利用Cookie的SameSite属性

[可以看看MDN对此的解释](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite)

`SameSite`可以设置为三个值，`Strict`、`Lax`和`None`。

1. 在`Strict`模式下，浏览器完全禁止第三方请求携带Cookie。比如请求`sanyuan.com`网站只能在`sanyuan.com`域名当中请求才能携带 Cookie，在其他网站请求都不能。
2. 在`Lax`模式，就宽松一点了，但是只能在 `get 方法提交表单`况或者`a 标签发送 get 请求`的情况下可以携带 Cookie，其他情况均不能。
3. 在None模式下，Cookie将在所有上下文中发送，即允许跨域发送。



#### 3. **CSRF Token**

前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。

那么我们可以使用Token，在不涉及XSS的前提下，一般黑客很难拿到Token。

可以看看这篇文章，将了Token是怎么操作的👉[彻底理解cookie，session，token](https://zhuanlan.zhihu.com/p/63061864)

Token(令牌)做为Web领域验证身份是一个不错的选择，当然了，JWT有兴趣的也可以去了解一下。

Token步骤如下：

**第一步:将CSRF Token输出到页面中**

> 首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了（XSS可能会获取Cookie），否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。



**第二步:页面提交的请求携带这个Token**

> 对于GET请求，Token将附在请求地址之后，这样URL 就变成 [http://url](https://link.zhihu.com/?target=http%3A//url)?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上：
> `<input type=”hidden” name=”csrftoken” value=”tokenvalue”/>`
> 这样，就把Token以参数的形式加入请求了。



**第三步：服务器验证Token是否正确**

> 当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。

非常感兴趣的，可以仔细去阅读一下相关的文章，Token是如何加密的，又是如何保证不被攻击者获取道。





### 总结

CSRF(Cross-site request forgery), 即跨站请求伪造，本质是冲着浏览器分不清发起请求是不是真正的用户本人，所以防范的关键在于在请求中放入黑客所不能伪造的信息。从而防止黑客伪造一个完整的请求欺骗服务器。

**防范措施**：验证码机制，验证来源站点，利用Cookie的SameSite属性，CSRF Token





## 参考

- [还在看那些老掉牙的性能优化文章么？这些最新性能指标了解下](https://juejin.im/post/5f0b056de51d45349917bf16#heading-4)
- [原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的](https://juejin.im/post/59c60691518825396f4f71a1)
- [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7)
- [实现图片懒加载的几种方案比较](https://juejin.im/post/5dbf7b6a6fb9a0207326b32b)
- [极客时间专栏](https://time.geekbang.org/column/article/138844)
- [还分不清 Cookie、Session、Token、JWT？](https://zhuanlan.zhihu.com/p/152224669)



## **❤️ 感谢大家**

如果你觉得这篇内容对你挺有有帮助的话：

1. 点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）

2. 欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。

3. 觉得不错的话，也可以看看往期文章：

   [[诚意满满👍\]Chrome DevTools调试小技巧，效率➡️🚀🚀🚀](https://juejin.im/user/5ef326ab6fb9a07ebe237664/posts)

   [[实用👍\]推荐一些非常棒的前端网站](https://juejin.im/post/5f0dce476fb9a07e5b62d134)

   [[干货👍\]从详细操作js数组到浅析v8中array.js](https://juejin.im/post/5f02e7725188252e8272cd47)

   [[1.2W字👍\]写给女友的秘籍-浏览器工作原理（上）篇](https://juejin.im/post/5f007d32f265da22b64936bf)

   [[1.1W字\]写给女友的秘籍-浏览器工作原理（渲染流程）篇](https://juejin.im/post/5f05d12a5188252e8406e37b)

   [[建议👍\]再来100道JS输出题酸爽继续（共1.8W字+巩固JS基础）](https://juejin.im/post/5efb4ca5f265da23016c5c80)

   [[诚意满满✍\]带你填一些JS容易出错的坑](https://juejin.im/post/5f0884c9e51d453462004fae)



