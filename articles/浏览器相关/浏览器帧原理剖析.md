

## 前言

本文会介绍浏览器中帧（Frame）的概念，它的流程是怎么样的。

至于写这个文章的出发点在于，我很好奇浏览器中像素工作流程是怎么样的，什么时候开始的，最后的结果是什么。

查阅了些外文资料，本文提供了些参考，参考链接在文末。



## 缘由



### 五大关键渲染路径



像素输出到页面，肯定经历了很多的过程，那我们作为前端工程师，工作中需要注意的点是哪些呢，这里给出参考:

![渲染关键路径](../../images/浏览器相关/渲染关键路径.jpeg)



这五个主要的部分，应该是我们值得去关注的，因为我们拥有最大控制权的部分。至于每一个过程具体是怎么样的呢，不清楚的可以参考下图:



![](../../images/浏览器相关/浏览器中的帧/详细的工作.jpg)



所以在这么一个像素的管道里，每部分都有可能造成卡顿，所以我们需要额外的关注这些，毕竟那一部分不当，都会开了不必要的性能开销。



### 三种输出方式

当时我的疑问是: 难道每一帧都总是会经过管道每个部分的处理嘛，其实不是这样子的，从视觉的角度来说，管道针对指定帧的运行通常有三种方式:

![](../../images/浏览器相关/浏览器中的帧/指定帧的运行通常有三种方式.jpg)



如果我们以第三种方式来更新视图，也就是更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。



### 跑个demo



为了更加具体的验证上述的过程，可以动手跑一个demo，来验证一下。

> demo地址:https://googlechrome.github.io/devtools-samples/jank/

![](../../images/浏览器相关/浏览器中的帧/主线程-火焰图.jpg)

我们添加多个dom元素进行动画，效果更佳明显，接着我们打开Performance，Record这个过程，我们需要关注的是Main选项卡，也就是主线程，我们在放大里面的Task，就有了下图:

![](../../images/浏览器相关/浏览器中的帧/主线程-火焰图-2.jpg)



经历的过程，也是很清楚看到，Update Layer Tree -->> Layout -->> Paint -->> Composite Layers。

> 如果你不是很清楚Performance中名称的含义,可以参考下面这篇文章，[点这里](https://mp.weixin.qq.com/s/iodsGPWgYc97yWLb09Xk6A):
>
> https://mp.weixin.qq.com/s/iodsGPWgYc97yWLb09Xk6A

接着，我们按下，Optimize按钮，按照之前的流程走，Record后，发现不对劲，还是这样子步骤，难道是哪里存在问题嘛，好奇的我，打开了Sources面板，然后就发现了:

![](../../images/浏览器相关/浏览器中的帧/优化后的动画-1.jpg)

它的源码优化动画，使用的是rAF,了解过的人一定不会陌生，你可以简单的理解就是:按帧对网页进行重绘。这里就引出了帧的概念，后续会说明。

> rAF的详细介绍，后续会对它进行梳理，可以持续关注。

### 如何避免回流与重绘 



回到前面我们设想的点，我们如何才能保证直接跳到合成过程，避免Layout以及Paint呢，当然有，我们需要对app.js中的uppdate函数进行改造，使用**transform: translateX(0px);**  做动画，做完update函数的处理逻辑后，我们再次Record一下:



![](../../images/浏览器相关/浏览器中的帧/优化后的动画-2.jpg)



从Task子任务中，我们可以发现，**Layout -->> Paint**, 布局和绘制的过程跳过了。这也是为什么我们常说的需要避免回流与重绘。从主线程上来看，能够完全的避免这些过程，避免了很多的运算开销。



这也是为什么经常可以看到这样子的建议:

- 坚持使用 transform 和 opacity 属性更改来实现动画。
- 使用 `will-change` 或 `translateZ` 提升移动的元素。

至于使用will-change和translatez来提升图层，这又是另外知识点了，这里就不张开了。



介绍到这里，我们已经清楚的明白，避免回流和重绘的意义，那么我们提到的**帧**和**rAF** 与 渲染路径有啥关系呢。



## 帧

我做的第一件事情就是google，然后维基百科给出如下定义:

> 在[视频](https://zh.wikipedia.org/wiki/视频)领域，[电影](https://zh.wikipedia.org/wiki/电影)、[电视](https://zh.wikipedia.org/wiki/电视)、[数字视频](https://zh.wikipedia.org/wiki/数字视频)等可视为随时间连续变换的许多张画面，其中**帧**是指每一张画面。

嗯，不是很好理解，知道我找到了这张图，才解答了我的困惑:

![](../../images/浏览器相关/浏览器中的帧/frame.svg)

这就真的是**一图胜千言**。

这个图，你可以理解成就是像素放到屏幕的完整过程。你肯定对里面的一些关键信息很迷惑，这里作出一些解释。



### PROCESSES(进程)

映入眼帘的就是进程:

- **Renderer Process**: 渲染进程。
  - 一个标签的周围容器。
  - 它包含了多个线程，这些线程共同负责让你的页面出现在屏幕上的各个环节。
  - 这些线程是**合成线程**（Compositor）、**图块栅格化线程**（Tile Worker）和主线程。
- **GPU Process**:  GPU进程。
  - 这是服务于所有标签和周围浏览器进程的单一进程。
  - 当帧被提交时，GPU进程将上传任何磁贴和其他数据（如四维顶点和矩阵）到GPU，以便实际将像素推送到屏幕上。
  - GPU进程包含一个单一的线程，称为GPU线程，实际完成工作。











## 参考

[1] **w3c-longTasks:** https://github.com/w3c/longtasks

[2] **chrome-fps-meter:** https://developer.chrome.com/docs/devtools/evaluate-performance/reference/#fps-meter

[3] **devtools-samples:** https://googlechrome.github.io/devtools-samples/jank/

[4] **Analyze runtime performance:** https://developer.chrome.com/docs/devtools/evaluate-performance/

[5] **Timeline Event Reference:** https://developer.chrome.com/docs/devtools/evaluate-performance/performance-reference/

[6] **The Anatomy of a Frame:** https://aerotwist.com/blog/the-anatomy-of-a-frame/

[7] **performance-rendering:** https://developers.google.com/web/fundamentals/performance/rendering

[8] **维基百科:** https://zh.wikipedia.org/wiki/

