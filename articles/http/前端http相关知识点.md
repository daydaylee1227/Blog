## 前言

这次梳理的篇幅主要是涉及网络部分，包括HTTP，TCP等协议，有了更加深入的了解，对巩固自己的网络知识体系也是很有帮助的，进一步的对性能优化上也是帮助很大的。





> 感谢掘友的鼓励与支持🌹🌹🌹，往期文章都在最后梳理出来了(●'◡'●)



接下来就以问题的形式展开梳理👇



## HTTP协议优缺点

超文本传输协议，**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**。

### HTTP 特点

1. 灵活可扩展。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。
2. 请求-应答模式，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。
3. 可靠传输，HTTP是基于TCP/IP，因此把这一特性继承了下来。
4. 无状态，这个分场景回答即可。

### HTTP 缺点

1. **无状态**，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。
2. **明文传输**，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。
3. **队头阻塞**，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。





-------







## HTTP 状态码知道哪些？分别什么意思？

RFC 规定 HTTP 的状态码为**三位数**，第一个数字定义了响应的类别，被分为五类:

- **1xx**: 代表请求已被接受，需要继续处理。
- **2xx**: 表示成功状态。
- **3xx**: 重定向状态。
- **4xx**: 客户端错误。
- **5xx**: 服务器端错误。



### 1xx 信息类

接受的请求正在处理，信息类状态码。

### 2xx 成功

- 200 OK 表示从客户端发来的请求在服务器端被正确请求。
- 204 No content，表示请求成功，但没有资源可返回。
- 206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求
  响应报文中包含由 **Content-Range** 指定范围的实体内容。



### 3xx 重定向

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存。
- 302 found，临时性重定向，表示资源临时被分配了新的 URL。
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源。
- 304 not modified，当协商缓存命中时会返回这个状态码。
- 307 temporary redirect，临时重定向，和302含义相同,不会改变method



>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送
>301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做



### 4XX 客户端错误

- 400 bad request，请求报文存在语法错误。
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息。
- 403 forbidden，表示对请求资源的访问被服务器拒绝。
- 404 not found，表示在服务器上没有找到请求的资源。
- 405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法，如下 👇

```
Access-Control-Allow-Methods →GET,HEAD,PUT,PATCH,POST,DELETE
```



### 5XX 服务器错误

- 500 internal sever error，表示服务器端在执行请求时发生了错误。
- 502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。





------





## HTTP 缓存有哪几种？

这个跟之前的浏览器缓存原理一样，我直接拿我之前梳理过的吧。

我在我之前的那一篇中已经详细的说过了，[点这里传送门聊一聊浏览器缓存](https://juejin.im/post/5f184aade51d4534aa4ad7c0#heading-40)

我们来梳理一下吧👇



### 强缓存

强缓存两个相关字段，**Expires**，**Cache-Control**。

**强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。**

首先检查强缓存，这个阶段**不需要发送HTTP请求。**通过查找不同的字段来进行，不同的HTTP版本所以不同。

- HTTP1.0版本，使用的是Expires，HTTP1.1使用的是Cache-Control



#### Expires

`Expires`即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:

```
Expires:Mon, 29 Jun 2020 11:10:23 GMT
```

表示该资源在2020年`7月29日11:10:23`过期，过期时就会重新向服务器发起请求。

这个方式有一个问题：**服务器的时间和浏览器的时间可能并不一致**，所以HTTP1.1提出新的字段代替它。

#### Cache-Control

HTTP1.1版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是max-age。

```
Cache-Control:max-age=6000
```

上面代表该资源返回后6000秒，可以直接使用缓存。

当然了，它还有其他很多关键的指令，梳理了几个重要的👇



注意点：

- 当Expires和Cache-Control同时存在时，优先考虑Cache-Control。
- 当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存👇



### 协商缓存

强缓存失效后，浏览器在请求头中携带响应的`缓存Tag`来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。

缓存分为两种，**Last-Modified** 和 **ETag**。两者各有优势，并不存在谁对谁有`绝对的优势`，与上面所讲的强缓存两个Tag所不同。

#### Last-Modified

这个字段表示的是**最后修改时间**。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，**如果再次请求**，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中`该资源的最后修改时间`对比:

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
- 否则返回304，告诉浏览器直接使用缓存。





#### ETag

ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。

浏览器接受到ETag值，会在下次请求的时候，将这个值作为**If-None-Match**这个字段的内容，发给服务器。

服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对👇

- 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存
- 如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样



#### 两者对比

- 性能上，`Last-Modified`优于`ETag`，`Last-Modified`记录的是时间点，而`Etag`需要根据文件的MD5算法生成对应的hash值。
- 精度上，`ETag`优于`Last-Modified`。`ETag`按照内容给资源带上标识，能准确感知资源变化，`Last-Modified`在某些场景并不能准确感知变化，比如👇
  - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。



最后，**如果两种方式都支持的话，服务器会优先考虑`ETag`**。



### 缓存位置

接下来我们考虑使用缓存的话，缓存的位置在哪里呢？

浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别👇

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

#### Service Worker

这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：`离线缓存`、`消息推送`和`网络代理`，其中`离线缓存`就是**Service Worker Cache**。



#### Memory Cache

指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

#### Disk Cache

存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。



#### Disk Cache VS Memory Cache

两者对比，主要的策略👇

内容使用率高的话，文件优先进入磁盘

比较大的JS，CSS文件会直接放入磁盘，反之放入内存。



#### Push Cache

推送缓存，这算是浏览器中最后一道防线吧，它是`HTTP/2`的内容。具体我也不是很清楚，有兴趣的可以去了解。



### 总结

- 首先检查`Cache-Control`， 尝鲜，看强缓存是否可用
- 如果可用的话，直接使用
- 否则进入协商缓存，发送HTTP请求，服务器通过请求头中的`If-Modified-Since`或者`If-None-Match`字段检查资源是否更新
- 资源更新，返回资源和200状态码。
- 否则，返回304，直接告诉浏览器直接从缓存中去资源。



------



## 说一说HTTP 的请求方法？

`http/1.1`规定了以下请求方法(注意，都是大写):

- GET：                请求获取Request-URI所标识的资源
- POST：              在Request-URI所标识的资源后附加新的数据
- HEAD：             请求获取由Request-URI所标识的资源的响应消息报头
- PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）
- DELETE：          请求服务器删除对应所标识的资源
- TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断
- CONNECT：      建立连接隧道，用于代理服务器
- OPTIONS：       列出可对资源实行的请求方法，用来跨域请求



---------



## 谈一谈GET 和 POST 的区别

本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。

想装逼请参考 https://zhuanlan.zhihu.com/p/22536382

具体差别👇

- 从缓存角度看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。
- 从参数角度来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。
- 从编码角度看，GET请求只能经行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。
- GET请求幂等，POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。
- GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。



从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。

-----------



## 谈一谈你对URL理解

统一资源定位符的简称，Uniform Resource Locator，常常被称为网址，是因特网上标准的资源地址。

### 组成

通用的格式：scheme://host[:port]/path/…/?query#anchor



| 名称         | 功能                                                         |
| ------------ | :----------------------------------------------------------- |
| scheme       | 访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等 |
| host         | HTTP 服务器的 IP 地址或者域名                                |
| port         | HTTP 服务器的默认端口是 80，HTTPS默认端口是443，这种情况下端口号可以省略，如果使用了别的端口，必须指明。不同的端口，你可以认为是不同的应用程序。 |
| path         | 访问资源的路径                                               |
| query-string | 发给 http 服务器的数据                                       |
| anchor       | 锚点                                                         |

举个例子👇

```
https://www.baidu.com/s?tn=baidu&bar=&wd=TianTian
```

这个URL中，https就是协议，www.baidu.com就是域名，默认端口是443，/s就是请求的path，`tn=baidu&bar=&wd=TianTian`这个就是query



### URL 编码

- URL 只能使用 [ASCII 字符集](https://www.w3school.com.cn/tags/html_ref_ascii.asp)来通过因特网进行发送。
- 由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。
- URL 编码使用 "%" 其后跟随两位的十六进制数来替换非 ASCII 字符。
- URL 不能包含空格。URL 编码通常使用 + 来替换空格。

举个例子👇

`天天`转换为有效的ASCII格式就是`%CC%EC%CC%EC`



-------



## 对Accept系列字段理解









------------





## 谈一谈HTTP代理



----------



## 谈一谈队头阻塞问题







------





## 谈一谈HTTP数据传输









-------------









## 谈一谈HTTPS与HTTP关系









-------



## HTTP/1.0 与HTTP/1.1



## 参考

- [图解 HTTP 缓存](https://juejin.im/post/5eb7f811f265da7bbc7cc5bd)
- [看完这篇HTTP，跟面试官扯皮就没问题](https://juejin.im/post/5e1870736fb9a02fef3a5dcb#heading-40)了