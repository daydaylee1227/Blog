## 前言

梳理了一份面试高频考点题目，覆盖的点不是很全，分享给你们，希望你们秋招顺序❤️❤️❤️



## HTML系列

### 你是如何理解 HTML 语义化的？

HTML语义化就是让页面内容结构化，它有如下优点

```
1、易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
2、有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
3、方便其他设备解析，如盲人阅读器根据语义渲染网页
4、有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐
```

如：

```
<header>代表头部
<nav>代表超链接区域
<main>定义文档主要内容
<article>可以表示文章、博客等内容
<aside>通常表示侧边栏或嵌入内容
<footer>代表尾部
```



可以跟面试官讲的更具体一点👇

第一个是荒野阶段，那时候前端的代码主要是后台来写的，所以那个时候写的代码主要是用table来布局的。

第二阶段---美工阶段，这个时候就有专门的人来前端代码了，这个阶段的布局主要是DIV+CSS布局，但是呢有一个问题，就是不够语义化。

第三个阶段-->> 前端阶段，也就是利用具有语义的标签，比如p,h1,h2,article，header，nav，main，aside，footer这些标签，使用这些正确的标签，可以表达正确的内容，也利于开发和维护。





### meta viewport 是做什么用的，怎么写？

<meta name="viewport" content="width=device-width, initial-scale=1">

通常viewport是指视窗、视口。浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域。在移动端和pc端视口是不同的，pc端的视口是浏览器窗口区域，而在移动端有三个不同的视口概念：布局视口、视觉视口、理想视口



meta有两个属性name 和 http-equiv

#### name

- keywords(关键字)   告诉搜索引擎，你网页的关键字

- description(网站内容描述)   用于告诉搜索引擎，你网站的主要内容。

- viewport(移动端的窗口)  后面介绍

- robots(定义搜索引擎爬虫的索引方式) robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引

- author(作者)

- generator(网页制作软件）

- copyright(版权)

  


#### http-equiv

> http-equiv顾名思义，相当于http的文件头作用。

有以下参数：

- content-Type 设定网页字符集

  <meta http-equiv="content-Type" content="text/html;charset=utf-8">  //旧的HTML，不推荐

  <meta charset="utf-8"> //HTML5设定网页字符集的方式，推荐使用UTF-8

- X-UA-Compatible(浏览器采用哪种版本来渲染页面)

   <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/> //指定IE和Chrome使用最新版本渲染当前页面

- cache-control（请求和响应遵循的缓存机制）

  <meta http-equiv="cache-control" content="no-cache">

- expires(网页到期时间)

  <meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" />





### 你用过哪些 HTML 5 标签？

```
有<header>、<footer>、<aside>、<nav>、<video>、<audio>、<canvas>等...
```





**canvas画布**

```
const ctx = canvas.getContext('2d');  // 获取它的2d上下文
ctx.fillStyle = 'green';    // 设置笔刷的填充色
ctx.fillRect(10, 10, 100, 100);  //  利用画笔范围,矩形，比如圆
```



#### video

autoplay 布尔属性；视频马上自动开始播放，不会停下来等着数据载入结束。

**controls**   提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。 

**loop** 布尔属性；指定后，会在视频结尾的地方，自动返回视频开始的地方。

**track**标签表示的是字幕

**poster** 表示的是封面

```
<track kind="subtitles" src="foo.en.vtt" srclang="en" label="English">
```



### H5 是什么？-->>移动端页面

h5一般指的是开一个WebView来加载页面吧，

**WebView是一种控件，它基于webkit引擎，因此具备渲染Web页面的功能。**

基于Webview的混合开发，就是在 Anddroid (安卓)/(苹果)原生APP里，通过WebView控件嵌入Web页面。

很多APP都是外边套原生APP的壳，内容是H5页面(基于html+css+js的Web页面)。现在的移动端混合开发软件，如果对于交互渲染要求不是特别高的项目，基本都是这么玩的。

**WebView作用**

- 显示和渲染Web页面
- 直接使用html文件（网络上或本地assets中）作布局
- 可和JavaScript交互调用



HTML5新特性：

1. 本地存储特性
2. 设备兼容特性 HTML5提供了前所未有的数据与应用接入开放接口
3. 连接特性 WebSockets
4. 网页多媒体特性 支持Audio Video SVG Canvas WebGL CSS3
5. CSS3特性



增加`拖放API`、`地理定位`、`SVG绘图`、`canvas绘图`、`Web Worker`、`WebSocket`

---------





## DOM

### 事件冒泡

事件会从最内层的元素开始发生，一直向上传播，直到document对象。

```
<div id="outer">
    <p id="inner">Click me!</p>
</div>
```

因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是

**p -> div -> body -> html -> document**



### **事件捕获**

与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。

上面的例子在事件捕获的概念下发生click事件的顺序应该是

**document -> html -> body -> div -> p**



![](C:\Users\DayDay\Desktop\Blog\images\面试总结\事件冒泡和事件捕获.png)



所以从上面的图片来看👉1-5是捕获过程，5-6是目标阶段，6-10是冒泡阶段



### addEventListener

addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。

```
 element.addEventListener(event, function, useCapture)
```

重点来看看第三个参数`useCapture`

- true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）
- false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）



所以我们通常来说，默认第三个参数不写的话，是按照事件句柄在冒泡执行的。

### attachEvent

兼容IE的写法，默认是事件冒泡阶段调用处理函数，写事件名时候要加上"on"前缀（"onload"、"onclick"等）。

```
object.attachEvent(event, function)
```



### 事件代理

利用事件流的特性，我们可以使用一种叫做事件代理的方法，其实利用的就是事件冒泡的机制。

```
<ul id="xxx">下面的内容是子元素1
        <li>li内容>>> <span> 这是span内容123</span></li>
        下面的内容是子元素2
        <li>li内容>>> <span> 这是span内容123</span></li>
        下面的内容是子元素3
        <li>li内容>>> <span> 这是span内容123</span></li>
</ul>
```

js代码

```
xxx.addEventListener('click', function (e) {
            console.log(e,e.target)
            if (e.target.tagName.toLowerCase() === 'li') {
                console.log('打印')
            }
})
```

更加规范的写法👇

```js
		function delegate(element, eventType, selector, fn) {
            element.addEventListener(eventType, e => {
                let el = e.target
                while (!el.matches(selector)) {
                    if (element === el) {
                        el = null
                        break
                    }
                    el = el.parentNode
                }
                el && fn.call(el, e, el)
            },true)
            return element
        }
```



### 阻止事件冒泡和默认事件

```
event.preventDefault()   // 阻止默认事件
event.stopPropagation() //阻止冒泡
```





### 实现一个可以拖拽的DIV

```
<div id="xxx"></div>
```



```
var dragging = false
var position = null

xxx.addEventListener('mousedown',function(e){
  dragging = true
  position = [e.clientX, e.clientY]
})


document.addEventListener('mousemove', function(e){
  if(dragging === false) return null
  console.log('hi')
  const x = e.clientX
  const y = e.clientY
  const deltaX = x - position[0]
  const deltaY = y - position[1]
  const left = parseInt(xxx.style.left || 0)
  const top = parseInt(xxx.style.top || 0)
  xxx.style.left = left + deltaX + 'px'
  xxx.style.top = top + deltaY + 'px'
  position = [x, y]
})
document.addEventListener('mouseup', function(e){
  dragging = false
})
```



## CSS系列

### 两种盒模型分别说一下

也就是标准盒模型写起来更方便，也更规范吧。



盒模型分为标准盒模型和怪异盒模型(IE模型)

```
box-sizing：content-box   //标准盒模型
box-sizing：border-box    //怪异盒模型
```

**content-box**

> 默认值，标准盒子模型。 [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 与 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height) 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。注意: 内边距、边框和外边距都在这个盒子的外部。 比如说，`.box {width: 350px; border: 10px solid black;}` 在浏览器中的渲染的实际宽度将是 370px。

尺寸计算公式：

`width` = 内容的宽度

`height` = 内容的高度

宽度和高度的计算值都不包含内容的边框（border）和内边距（padding）。



**border-box**

> [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 和 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height) 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的[盒模型](https://developer.mozilla.org/en-US/docs/CSS/Box_model)。注意，填充和边框将在盒子内 , 例如, `.box {width: 350px; border: 10px solid black;}` 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。



尺寸计算公式：

*width = border + padding + 内容的宽度*

*height = border + padding + 内容的高度*



注意：如果你在设计页面中，发现内容区被撑爆了，那么就先检查一下border-sizing是什么，最好在引用reset.css的时候，就对border-sizing进行统一设置，方便管理





### 如何垂直居中？

[16种方法实现水平居中垂直居中](https://juejin.im/post/58f818bbb123db006233ab2a)

#### 水平局中

**内联元素**，**宽度默认就是内容的宽度**，只需要给父级添加text-align

```
.wrapper{text-align: center;}
```

**块级元素**，将它的margin-left和margin-right设置为auto，并且块级元素一定要设置宽度，否则元素默认为100%宽度，不需要居中。

```
.inner{
            display: block;
            width: 150px;
            margin: 0 auto;
        }
// 一定要设置宽度，不然就不需要局中了
```

两个以上的水平局中，可以将其设置为`display:inline-block`，在设置父级text-align





#### 垂直局中

**内联元素**，第一种实用的是flex布局，这里局中的值得是相对于父盒子

```
.wrapper{
            display: flex;
            align-items: center;
        }
```

第二种，这里面指的局中是相对于自身而言的

```
.inner{
            height:100px;
            line-height:100px;
}
```

**块级元素**

宽高确定情况下，实用 **position absolute + 负margin**

宽高不确定的情况下，实用**position absolute + transform**



#### 垂直水平局中

子元素宽高确定的情况下，使用**position absolute + 负margin**

子元素宽高不确定的，使用**position absolute + transform**

```
.inner{
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            background: blue;
        }
```

当然了flex布局也是可以解决问题的，下面就介绍👇



---------



### 两列布局

#### 左列定宽,右列自适应

**float+margin**

```
.left{
            float: left;
            width: 100px;
            height: 100%;
            background: rebeccapurple;
        }
        .rigth{
            height: 100%;
            margin-left: 100px; /*大于等于#left的宽度*/
            background: blue;
        }
```

#### 左列自适应,右列定宽

**float+overflow**

```
<div class="wrapper">
        <div class="rigth"></div>
        <div class="left"></div>
</div>

```

css代码👇

```
.rigth {
            margin-left: 10px;
            /*margin需要定义在#right中*/
            float: right;
            width: 100px;
            height: 100%;
            background-color: #0f0;
        }

        .left {
            overflow: hidden;
            /*触发bfc*/
            height: 100%;
            background-color: blue;
        }
```



--------



### 三列布局

#### 两列定宽,一列自适应

##### 使用float+margin实现

```
<div class="wrapper">
        <div class="left"></div>
        <div class="main"></div>
        <div class="rigth"></div>
    </div>
```

css代码



```
.wrapper {
            height: 400px;
            background: red;
            min-width: 500px;
        }

        .left {
            margin-left: 10px;
            float: left;
            width: 100px;
            height: 100%;
            background-color: #0f0;
        }
        .main{
            float: left;
            width: 100px;
            height: 100%;
            margin-left: 20px;
            background: brown;
        }
        .rigth {

            margin-left: 230px;  /*等于#left和#center的宽度之和加上间隔,多出来的就是#right和#center的间隔*/
            height: 100%;
            background-color: blue;
        }
```



**间列自适应宽度，旁边两侧固定宽度**

**双飞翼布局**

实现步骤

- 三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；
- 通过设置margin-left为负值让left和right部分回到与center部分同一行；
- center部分增加一个内层div，并设margin: 0 200px；



**html部分**

```
<div class="wrapper">
        
        <div class="main">
            <div class="inner"></div>
        </div>
        <div class="left"></div>
        
        <div class="right"></div>
    </div>
```

**css部分**

```css
.wrapper {
            /* //确保中间内容可以显示出来，两倍left宽+right宽 */
            min-width: 600px; 
        }

        .left {
            float: left;
            width: 200px;
            height: 400px;
            background: red;
            margin-left: -100%;
        }

        .main {
            float: left;
            width: 100%;
            height: 500px;
            background: yellow;
        }

        .main .inner {
            /* margin水平方向要是左右两者的宽度 */
            margin: 0 200px;    
            height: 100%;
            border: 2px solid brown;
        }
        .right {
            float: left;
            width: 200px;
            height: 400px;
            background: blue;
            margin-left: -200px;
        }
```





### flex 怎么用，常用属性有哪些？

[一劳永逸的搞定 flex 布局](https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb) 强烈推荐这篇，简短明了。

flex 的核心的概念就是 **容器** 和 **轴**。

#### 父容器

**justify-content 项目在主轴上的对齐方式**

- flex-start | flex-end | center | space-between | space-around

- space-between 子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。

- space-around  子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。

**align-items** **定义项目在侧轴上如何对齐**

- flex-start | flex-end | center | baseline | stretch;
- baseline: 项目的第一行文字的基线对齐。
- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。



#### 子容器

**align-self   单个项目对齐方式**

- align-self:   auto | flex-start | flex-end | center | baseline | stretch;



**flex：前面三个属性的简写 是flex-grow  flex-shrink flex-basis的简写**

- flex-grow 放大比例 根据所设置的比例分配盒子所剩余的空间
- flex-shrink 缩小比例 设置元素的收缩比例   多出盒子的部分，按照比例的大小砍掉相应的大小，即比例越大，被砍的越大，默认值是1
- flex-basis  伸缩基准值 项目占据主轴的空间 
- flex-basis 该属性设置元素的宽度或高度，当然width也可以用来设置元素宽度，如果元素上同时出现了width 和flex-basis那么flex-basis会覆盖width的值

flex: 0 1 auto； 默认主轴是row,那么不会去放大比例，如果所有的子元素宽度和大于父元素宽度时，就会按照比例的大小去砍掉相应的大小。



#### 轴

**flex-direction 决定主轴的方向  即项目的排列方向**

row | row-reverse | column | column-reverse





### BFC 是什么？

[深入理解BFC和外边距合并(Margin Collapse)](https://www.cnblogs.com/chakson/p/4972286.html)

BFC全称是Block Formatting Context，即块格式化上下文。

`BFC`就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

下列方式会创建**块格式化上下文**：

1. 根元素
2. float属性不为none
3. position为absolute或fixed
4. display为inline-block, table-cell, table-caption, flex, inline-flex
5. overflow不为visible



需要背的条件👇

1. 浮动元素（元素的 float 不是 none）
2. 绝对定位元素（元素的 position 为 absolute 或 fixed）
3. 行内块元素
4. overflow 值不为 visible 的块元素
5. 弹性元素（display为 flex 或 inline-flex元素的直接子元素）



**BFC布局规则**

1. 内部的Box会在垂直方向，一个接一个地放置。
2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4. BFC的区域不会与float box重叠。
5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6. 计算BFC的高度时，浮动元素也参与计算





### 选择器优先级

**css常用选择器**

```markdown
通配符：*
ID选择器：#ID
类选择器：.class
元素选择器：p、a    等
后代选择器：p span、div a   等
伪类选择器：a:hover 等
属性选择器：input[type="text"]  等
```

**css选择器权重**

!important -> 行内样式 -> #id -> .class -> 元素和伪元素 -> * -> 继承 -> 默认



### CSS新特性

```
transition：过渡
transform：旋转、缩放、移动或者倾斜
animation：动画
gradient：渐变
shadow：阴影
border-radius：圆角
```



### 清除浮动说一下

第一种用伪元素

```
.clearfix:after{
  content: "";
  display: block;
  clear: both; 
}

 .clearfix{
     zoom: 1; /* IE 兼容*/
 }
```

第二种给父容器添加 overflow:hidden 或者 auto 样式

```
overflow:hidden;
```



### 三种地位方案

在定位的时候，浏览器就会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。定位时，有三种定位方案，分别是常规流，浮动已经绝对定位。

#### 常规流(Normal flow)

- 在常规流中，盒一个接着一个排列;
- 在**块级格式化上下文**里面， 它们**竖着**排列；
- 在**行内格式化上下文**里面， 它们**横着**排列;
- 当`position`为`static`或`relative`，并且`float`为`none`时会触发常规流；
- 对于**静态定位**(static positioning)，`position: static`，**盒的位置是常规流布局里的位置**；
- 对于**相对定位**(relative positioning)，`position: relative`，盒偏移位置由这些属性定义`top`，`bottom`，`left`and`right`。**即使有偏移，仍然保留原有的位置**，其它常规流不能占用这个位置。

#### 浮动(Floats)

- 盒称为浮动盒(floating boxes)；
- 它位于当前行的开头或末尾；
- 这**导致常规流环绕在它的周边**，除非设置 clear 属性；

#### 绝对定位(Absolute positioning)

- 绝对定位方案，**盒从常规流中被移除**，不影响常规流的布局；
- 它的定位相对于它的包含块，相关CSS属性：`top`，`bottom`，`left`及`right`；
- 如果元素的属性`position`为`absolute`或`fixed`，它是绝对定位元素；
- 对于`position: absolute`，元素定位将相对于最近的一个`relative`、`fixed`或`absolute`的父元素，如果没有则相对于`body`；



### 获取DOM

```
<div id="css-cell">
        <div class="heart"></div>
        <div class="sun"></div>
</div>
    
 		let oDiv = document.getElementById('css-cell')
        let oDiv1 = document.getElementsByTagName('div')   //集合 根据标签
        let oDiv2 = document.querySelectorAll('div')     // 集合  标签       
        let oDiv3 = document.getElementsByClassName('heart')     // className    
```



### Attribute与Property

attribute：是HTML标签上的某个属性，如id、class、value等以及自定义属性

property：是js获取的DOM对象上的属性值，比如a，你可以将它看作为一个基本的js对象。

```
let demo11 = oDiv.getAttribute('class');
let demo2 = oDiv.setAttribute('data-name','new-value')
```



-------



## JS系列

### 作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。



### 闭包的应用

闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部





### ES 6 语法知道哪些，分别怎么用？

let const 块级作用域 箭头函数 词法this

**整理列表**



### 手写函数防抖和函数节流

**节流throttle**

规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

```
function throttle(fn, delay) {
            let flag = true,
                timer = null
            return function(...args) {
                let context = this
                if(!flag) return
                
                flag = false
                clearTimeout(timer)
                timer = setTimeout(function() {
                    fn.apply(context,args)
                    flag = true
                },delay)
            }
        }
```



**防抖**

在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

```js
function debounce(fn, delay) {
            let timer = null
            return function(...args) {
                let context = this
                if(timer) clearTimeout(timer)
                timer = setTimeout(function(){
                    fn.apply(context,args)
                },delay)
            }
        }
```



### 手写AJAX

```
function ajax(url, method) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    xhr.open(url, method, true)
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(xhr.responseText)
        } else if (xhr.status === 404) {
          reject(new Error('404'))
        }
      } else {
        reject('请求数据失败')
      }
    }
    xhr.send(null)
  })
}
```



### 手写bind函数

```
Function.prototype.mybind = function(context, ...args) {
    return (...newArgs) => {
        return this.call(context, ...args, ...newArgs)
    }
}
```

### 实现call

```
Function.prototype.mycall = function (context, ...args) {
    context = Object(context) || window
    let fn = Symbol(1)
    context[fn] = this
    let result = context[fn](...args)
    delete context[fn]
    return result
}
```





this

闭包/立即执行函数是什么？

什么是 JSONP，什么是 CORS，什么是跨域？

async/await 怎么用，如何捕获异常？

如何实现深拷贝？

如何用正则实现 trim()？

不用 class 如何实现继承？用 class 又如何实现？

如何实现数组去重？

== 相关题目（反着答）

手写一个 Promise





## 浏览器相关



### Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session



### window.onload 与 DOMContentLoaded区别

onload指资源全部加载完成后才去相应的事件，包括图片等资源。

DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。





### 什么是 XSS？如何预防？

XSS 全称是 `Cross Site Scripting` ,为了与`CSS`区分开来，故简称 `XSS`，翻译过来就是“跨站脚本”。

XSS是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。发展到现在，往HTML文件中中插入恶意代码方式越来越多，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。

注入恶意脚本可以完成这些事情：

1. 窃取Cookie
2. 监听用户行为，比如输入账号密码后之间发给黑客服务器
3. 在网页中生成浮窗广告
4. 修改DOM伪造登入表单

一般的情况下，XSS攻击有三种实现方式

- 存储型 XSS 攻击
- 反射型 XSS 攻击
- 基于 DOM 的 XSS 攻击



#### 存储型 XSS 攻击



存储型 XSS 攻击大致步骤如下：

1. 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
2. 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
3. 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

比如常见的场景：

在评论区提交一份脚本代码，假设前后端没有做好转义工作，那内容上传到服务器，在页面渲染的时候就会`直接执行`，相当于执行一段未知的JS代码。这就是存储型 XSS 攻击。

#### 反射型 XSS 攻击

反射型 XSS 攻击指的就是恶意脚本作为**「网络请求的一部分」**，随后网站又把恶意的JavaScript脚本返回给用户，当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。

举个例子:

```
http://TianTianUp.com?query=<script>alert("你受到了XSS攻击")</script>
复制代码
```

如上，服务器拿到后解析参数query，最后将内容返回给浏览器，浏览器将这些内容作为HTML的一部分解析，发现是Javascript脚本，直接执行，这样子被XSS攻击了。

这也就是反射型名字的由来，将恶意脚本作为参数，通过网络请求，最后经过服务器，在反射到HTML文档中，执行解析。

主要注意的就是，**「服务器不会存储这些恶意的脚本，这也算是和存储型XSS攻击的区别吧」**。



#### 基于 DOM 的 XSS 攻击

基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，在数据传输的时候劫持网络数据包

常见的劫持手段有：

- WIFI路由器劫持
- 本地恶意软件

#### 阻止 XSS 攻击的策略

以上讲述的XSS攻击原理，都有一个共同点：让恶意脚本直接在浏览器执行。

针对三种不同形式的XSS攻击，有以下三种解决办法

**对输入脚本进行过滤或转码**

对用户输入的信息过滤或者是转码

举个例子👇

转码后👇

```
&lt;script&gt;alert(&#39;你受到XSS攻击了&#39;)&lt;/script&gt;
```

这样的代码在 html 解析的过程中是无法执行的。

当然了对于`<script>`、`<img>`、`<a>`等关键字标签也是可以过来的，效果如下👇

```

```

最后什么都没有剩下了

**利用 CSP**

该安全策略的实现基于一个称作 `Content-Security-Policy`的 [HTTP](https://developer.mozilla.org/en-US/docs/Glossary/HTTP) 首部。

可以移步[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)，有更加规范的解释。我在这里就是梳理一下吧。

CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能👇

- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
- 禁止向第三方域提交数据，这样用户数据也不会外泄；
- 提供上报机制，能帮助我们及时发现 XSS 攻击。
- 禁止执行内联脚本和未授权的脚本；

**利用 HttpOnly**

由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。这样子的话，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。

通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：

```
set-cookie: NID=189=M8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly
```

#### 总结

`XSS` 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为`存储型`、`反射型`和`文档型`。防范的措施包括:

- 对输入内容过滤或者转码，尤其是类似于`<script>`、`<img>`、`<a>`标签
- 利用CSP
- 利用Cookie的HttpOnly属性

除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。





### 什么是 CSRF？如何预防？





Eventloop 说一下

### JS 垃圾回收机制



## 网络部分

### HTTP 状态码知道哪些？分别什么意思？

状态码：由3位数字组成，第一个数字定义了响应的类别

**1xx：指示信息，表示请求已接收，继续处理**

**2xx：成功，表示请求已被成功接受，处理。**

```
200 OK：客户端请求成功
204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。
206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容

```

**3xx：重定向**

```js
301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。

302 Found：临时重定向，表示请求的资源临时搬到了其他位置

303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问

307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET

304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有

```

**4xx：客户端错误**

```
400 Bad Request：客户端请求有语法错误，服务器无法理解。
401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
403 Forbidden：服务器收到请求，但是拒绝提供服务
404 Not Found：请求资源不存在。比如，输入了错误的url
415 Unsupported media type：不支持的媒体类型
```

**5xx：服务器端错误，服务器未能实现合法的请求。**

```
500 Internal Server Error：服务器发生不可预期的错误。
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```





HTTP 缓存有哪几种？

GET 和 POST 的区别

## Vue相关

watch 和 computed 和 methods 区别是什么？

Vue 有哪些生命周期钩子函数？分别有什么用？

Vue 如何实现组件间通信？

Vue 数据响应式怎么做到的？

Vue.set 是做什么用的？

Vuex 你怎么用的？

VueRouter 你怎么用的？

路由守卫是什么？



Webpack
必考：有哪些常见 loader 和 plugin，你用过哪些？
英语题：loader 和 plugin 的区别是什么？
必考：如何按需加载代码？
必考：如何提高构建速度？
转义出的文件过大怎么办？

开放题目
必考：你遇到最难的问题是怎样的？
你在团队的突出贡献是什么？
最近在关注什么新技术
有没有看什么源码，看了后有什么记忆深刻的地方，有什么收获





## 模块化

将一个复杂的程序依据特定的规则(规范)封装成几个文件，然后将其组合在一起，这些只是向外暴露一些接口，或者方法，与其他模块进行通信，这样子叫做是模块化的过程。



**为什么要模块化**，目的在于减少复杂性，减少它们相互之间的功能关系。使每个模块功能单一。

**模块化好处**

- 避免了命名冲突(减少了命名空间污染)
- 更好的分离，按需加载
- 更高复用性
- 高维护性





### CommomJS

CommonJS定义了两个主要概念：

`require`函数，用于导入模块

`module.exports`变量，用于导出模块



### `require`

导入，代码很简单，`let {count,addCount}=require("./utils")`就可以了。

`require`的第一步是解析路径获取到模块内容：

- 如果是核心模块，比如`fs`，就直接返回模块
- 如果是带有路径的如`/`,`./`等等，则拼接出一个绝对路径，然后先读取缓存`require.cache`再读取文件。如果没有加后缀，则自动加后缀然后一一识别。
  - `.js` 解析为JavaScript 文本文件
  - `.json`解析JSON对象
  - `.node`解析为二进制插件模块
- 首次加载后的模块会缓存在`require.cache`之中，所以多次加载`require`，得到的对象是同一个。
- 在执行模块代码的时候，会将模块包装成如下模式，以便于作用域在模块范围之内。



### `module`

```
let count=0
function addCount(){
    count++
}
module.exports={count,addCount}
```

然后根据require执行代码时需要加上的，那么实际上我们的代码长成这样：

```
(function(exports, require, module, __filename, __dirname) {
    let count=0
    function addCount(){
        count++
    }
    module.exports={count,addCount}
});
```



### ES6模块与CommonJS的区别

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。