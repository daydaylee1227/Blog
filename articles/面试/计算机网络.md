## 计算机网络





### 经典的5层模型

应用层-->>传输层-->>网络层-->>数据链路层-->>物理层



#### 应用层

HTTP，FTP协议



#### 传输层

TCP，UDP





#### 物理层

定义数据传输如何在物理设备通信。 光纤，网卡 



#### 数据链路层

在通信与通信实体间建立数据链路链接，通过软件设备连接电路。



#### 网络层

为数据在节点之间传输创建逻辑链路。

比如我去访问百度这个网站，它是如何去查找的，这个就是提供了逻辑链路。



#### 传输层

向用户提供端对端的可靠服务，tcp，udp。



#### 应用层

http协议，构建在tcp协议上。

 

### [TCP三次握手](https://mp.weixin.qq.com/s/-vRhX03y5cttVZ099prwqw)



为了规避网络传输过程中，出现延时，丢包，导致服务器开销的问题。

  第一次握手，发送一个数据包，syn = 1，标志位，seq = N，通常等于1

第二次握手，syn = 1，ack = n+1， seq = y。

第三次握手，ack = y + 1， seq = z。



为了防止服务端开启一些无用连接，服务端的端口一直开着，等着客户端响应。



### 为什么三次握手

1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

2、换个易于理解的视角来看为什么要 3 次握手。

“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。



### 四次挥手

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。







### HTTP报文

请求报文，和响应报文。

包含三部分

- 起始行
- 首部
- 主体

 



### 跨域

[谈一谈跨域](https://juejin.cn/post/6854573215830933512#heading-65)

proxy_pass设置代理服务器,比如我们本地访问localhost下某个端口时,就会做请求转发到代理服务器。



nginx代理

proxy_cache_path 设置缓存的路径



### Cookie和Session

Cookie 是怎样工作的

在介绍 Cookie 是什么之前，我们来看看 Cookie 是如何工作的：

1. 首先，我们假设当前域名下还是没有 Cookie 的

2. 接下来，浏览器发送了一个请求给服务器(这个请求是还没带上 Cookie 的)

3. 服务器设置set-Cookie 并发送给浏览器(当然也可以不设置)

4. 浏览器将 Cookie 保存下来

5. 接下来，以后的每一次请求，都会带上这些 Cookie，发送给服务器



[Cookie](https://juejin.cn/post/6854573215830933512#heading-23)



### 数据协商

主要分为请求和返回时对应的数据。

#### 请求

- accept: text/html,application/xhtml+xml,
- **accept-language**:zh-CN
- accept-encoding: gzip, deflate, br, 规定服务端如何压缩
- **user-agent:** 浏览器相关信息



#### 返回

- content-type，返回的数据格式，告诉客户端最后如何显示。
- content-encoding，对应传输过程中数据如何压缩
- content-language:  返回的语言类型。





### [内容安全策略( CSP )](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)

你可以使用  [`Content-Security-Policy`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy) HTTP头部 来指定你的策略，像这样:

```js
Content-Security-Policy: policy
```

一个策略可以包含 [`default-src`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src) 或者 [`script-src`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/script-src) 指令来防止内联脚本运行, 并杜绝`eval()`的使用。





## [面试问题详解——TCP](https://leetcode-cn.com/circle/discuss/aqTOW4/)



## TCP 如何保障数据包有效





## [HTTPS 和 HTTP 的区别](https://zhuanlan.zhihu.com/p/108822858)





### 聊聊 TCP 和 UDP 的区别？

- TCP 面向连接，UDP 尽最大努力交付，无连接
- TCP 首部 20 字节，UDP 首部 4 字节 
- TCP 是可靠传输，详细讲了 TCP 保证可靠传输的机制, 超时重传、错误重传
- 还详细说了 TCP 慢启动，滑动窗口，重传机制





### **TCP粘包、拆包及解决办法**

**为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？**

> UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同
>
> 的数据报文区分开，从而避免粘包和拆包的问题。

对于TCP而言，

> TCP 是基于字节流的
>
> 在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。



**为什么会发生 TCP 粘包、拆包？**

- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
- 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。



**粘包、拆包解决办法**

- **消息定长：**发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- **设置消息边界：**服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 **FTP** 协议。



TFP应用层，跟HTTP属于同一层，以及dns。





### **TCP 可靠传输**

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：



### **TCP 滑动窗口**

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。



### **TCP 流量控制**

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

**实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段**，此数据段仅包含一个字节来获取最新的窗口大小信息。



### **TCP 拥塞控制**

> 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。



TCP 主要通过四个算法来进行拥塞控制：

**慢开始、拥塞避免、快重传、快恢复。** 





## 操作系统







### 线程

是进程中的一个实体，是被系统独立调度的基本单位



#### 好处

- 因为同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核
- 建一个新线程花费时间少
- 线程的终止时间比进程短



####  线程的特征

- 并发性
- 共享性
- 



### 进程与线程的区别

**进程是资源分配的最小单位，线程是CPU调度的最小单位**

做个简单的比喻：进程=火车，线程=车厢

[点击这里](https://www.zhihu.com/question/25532384)

[进程的介绍](https://sugarat.top/offer/experience/os.html#%E8%BF%9B%E7%A8%8B)





## 进程间通信的7种方式

匿名管道，有名管道，信号量，消息队列

**管道的实质：**
管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。

[点击这里](https://www.jianshu.com/p/c1015f5ffa74)





# 前言

我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。

在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~

希望这篇文章能帮到你，同时本文也会收录到我自己的[个人网站](http://blog.liuxuan.site/)。

# 为什么要有垃圾回收

在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过**malloc**函数去手动分配，在用完之后，还要时刻记得用**free**函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。

但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。

不需要我们去手动管理内存了，所以自然要有**垃圾回收**，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。

垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。

# 内存结构分配

由于V8最开始就是为JavaScript在浏览器执行而打造的，不太可能遇到使用大量内存的场景，所以它可以申请的最大内存就没有设置太大，在64位系统下大约为1.4GB，在32位系统下大约为700MB。

在NodeJS环境中，我们可以通过**process.memoryUsage()**来查看内存分配。

![clipboard.png](https://segmentfault.com/img/bVbwnTG?w=389&h=123)

**process.memoryUsage**返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，含义如下：

![clipboard.png](https://segmentfault.com/img/bVbwnUb?w=550&h=543)

```
rss（resident set size）：所有内存占用，包括指令区和堆栈

heapTotal：V8引擎可以分配的最大堆内存，包含下面的 heapUsed

heapUsed：V8引擎已经分配使用的堆内存

external： V8管理C++对象绑定到JavaScript对象上的内存
```

以上所有内存单位均为字节（Byte）。

如果说想要扩大Node可用的内存空间，可以使用**Buffer**等堆外内存内存，这里不详细说明了，大家有兴趣可以去看一些资料。

下面是Node的整体架构图，有助于大家理解上面的内容：

![clipboard.png](https://segmentfault.com/img/bVbwnUi?w=800&h=534)

```
Node Standard Library: 是我们每天都在用的标准库，如Http, Buffer 模块

Node Bindings: 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务

第三层是支撑 Node.js 运行的关键，由 C/C++ 实现：
1. V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机
2. Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力
3. C-ares：提供了异步处理 DNS 相关的能力
4. http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力
```

# 垃圾回收机制

## 如何判断是否可以回收

### 1.1 标记清除

当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如何标记变量并不重要，关键在于采取什么策略。

- （1）垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
- （2）然后，它会去掉运行环境中的变量以及被环境中变量所引用的变量的标记
- （3）此后，依然有标记的变量就被视为准备删除的变量，原因是在运行环境中已经无法访问到这些变量了。
- （4）最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。

![clipboard.png](https://segmentfault.com/img/bVbwnUo?w=406&h=318)

**活动对象**就是上面的root，如果不清楚活动对象的可以先查一下资料，当一个对象和其关联对象不再通过引用关系被当前root引用了，这个对象就会被垃圾回收。

### 1.2 引用计数

引用计数的垃圾收集策略不太常见。含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。

如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。

当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：**循环引用**。

循环引用是指对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用，看个例子：

```
function foo () {
    var objA = new Object();
    var objB = new Object();
    
    objA.otherObj = objB;
    objB.anotherObj = objA;
}
```

这个例子中，objA和objB通过各自的属性相互引用，也就是说，这两个对象的引用次数都是2。

在采用标记清除策略的实现中，由于函数执行后，这两个对象都离开了作用域，因此这种相互引用不是问题。

但在采用引用次数策略的实现中，当函数执行完毕后，objA和objB还将继续存在，因为它们的引用次数永远不会是0。

加入这个函数被重复多次调用，就会导致大量内存无法回收。为此，Netscape在Navigator 4.0中也放弃了引用计数方式，转而采用标记清除来实现其垃圾回收机制。

还要注意的是，我们大部分人时刻都在写着循环引用的代码，看下面这个例子，相信大家都这样写过：

```
var el = document.getElementById('#el');
el.onclick = function (event) {
    console.log('element was clicked');
}
```

我们为一个元素的点击事件绑定了一个匿名函数，我们通过**event**参数是可以拿到相应元素**el**的信息的。

大家想想，这是不是就是一个循环引用呢？
**el**有一个属性**onclick**引用了一个函数（其实也是个对象），函数里面的参数又引用了**el**，这样**el**的引用次数一直是2，即使当前这个页面关闭了，也无法进行垃圾回收。

如果这样的写法很多很多，就会造成内存泄露。我们可以通过在页面卸载时清除事件引用，这样就可以被回收了：

```
var el = document.getElementById('#el');
el.onclick = function (event) {
    console.log('element was clicked');
}

// ...
// ...

// 页面卸载时将绑定的事件清空
window.onbeforeunload = function(){
    el.onclick = null;
}
```