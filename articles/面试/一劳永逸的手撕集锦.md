## 前言

基本上面试的时候，经常会遇到手撕XXX之类的问题，这次准备梳理总结一遍，巩固我们原生JS基础的同时，下次想复习面试手撕题的时候，找起来方便，也节省时间。









## DOM

### 实现一个事件委托（易错）

事件委托这里就不阐述了，比如给li绑定点击事件

看错误版，(容易过的，看**面试官水平了**)👇

```js

ul.addEventListener('click', function (e) {
            console.log(e,e.target)
            if (e.target.tagName.toLowerCase() === 'li') {
                console.log('打印')  // 模拟fn
            }
})
```

**有个小bug，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对**👇

```
<ul id="xxx">下面的内容是子元素1
        <li>li内容>>> <span> 这是span内容123</span></li>
        下面的内容是子元素2
        <li>li内容>>> <span> 这是span内容123</span></li>
        下面的内容是子元素3
        <li>li内容>>> <span> 这是span内容123</span></li>
</ul>
```

这样子的场景就是不对的，那我们看看高级版本👇

```js
		function delegate(element, eventType, selector, fn) {
            element.addEventListener(eventType, e => {
                let el = e.target
                while (!el.matches(selector)) {
                    if (element === el) {
                        el = null
                        break
                    }
                    el = el.parentNode
                }
                el && fn.call(el, e, el)
            },true)
            return element
        }
```



### 实现一个可以拖拽的DIV

这个题目看起来简单，你可以试一试30分钟能不能完成，直接贴出代码吧👇

```
<div id="xxx"></div>
```

```js
var dragging = false
var position = null

xxx.addEventListener('mousedown',function(e){
  dragging = true
  position = [e.clientX, e.clientY]
})


document.addEventListener('mousemove', function(e){
  if(dragging === false) return null
  const x = e.clientX
  const y = e.clientY
  const deltaX = x - position[0]
  const deltaY = y - position[1]
  const left = parseInt(xxx.style.left || 0)
  const top = parseInt(xxx.style.top || 0)
  xxx.style.left = left + deltaX + 'px'
  xxx.style.top = top + deltaY + 'px'
  position = [x, y]
})
document.addEventListener('mouseup', function(e){
  dragging = false
})
```



## CSS





## JS

### 手写防抖和节流函数

**节流throttle**，规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。场景👇

- scroll滚动事件，每隔特定描述执行回调函数
- input输入框，每个特定时间发送请求或是展开下拉列表，（防抖也可以）

节流重在加锁**flag = false**

```
function throttle(fn, delay) {
            let flag = true,
                timer = null
            return function(...args) {
                let context = this
                if(!flag) return
                
                flag = false
                clearTimeout(timer)
                timer = setTimeout(function() {
                    fn.apply(context,args)
                    flag = true
                },delay)
            }
        }
```





**防抖debounce**,在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。场景👇

- 浏览器窗口大小resize避免次数过于频繁
- 登录，发短信等按钮避免发送多次请求
- 文本编辑器实时保存

防抖重在清零**clearTimeout(timer)**

```
function debounce(fn, delay) {
            let timer = null
            return function(...args) {
                let context = this
                if(timer) clearTimeout(timer)
                timer = setTimeout(function(){
                    fn.apply(context,args)
                },delay)
            }
        }
```







### 手写AJAX



### 深拷贝



### 用正则实现 trim()



### 实现数组去重



实现Object.create方法



### 手写call和apply



### 手写bind



### new



### 实现一个对象类型的函数

核心：Object.prototype.toString 

```
let isType = (type) => (obj) => Object.prototype.toString.call(obj) === `[object ${type}]`

// let isArray = isType('Array')
// let isFunction = isType('Function')
// console.log(isArray([1,2,3]),isFunction(Map))
```

isType函数👆，也属于**偏函数**的范畴，偏函数实际上是返回了一个包含**预处理参数**的新函数。



### 实现instanceof

**instanceof** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

语法👇

```
object instanceof constructor
object 某个实例对象
construtor 某个构造函数
```

原型链的向上找，找到原型的最顶端，也就是Object.prototype，代码👇

```
function my_instance_of(leftVaule, rightVaule) {
    if(typeof leftVaule !== 'object' || leftVaule === null) return false;
    let rightProto = rightVaule.prototype,
        leftProto = leftVaule.__proto__;
    while (true) {
        if (leftProto === null) {
            return false;
        }
        if (leftProto === rightProto) {
            return true;
        }
        leftProto = leftProto.__proto__
    }
}

```



### 实现柯里化函数



### 实现数组flat



### 实现sleep



### 实现数组reduce



### 用发布订阅模式实现EventEmit



### 实现Promise.all和race