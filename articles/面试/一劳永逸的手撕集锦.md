## 前言

基本上面试的时候，经常会遇到手撕XXX之类的问题，这次准备梳理总结一遍，巩固我们原生JS基础的同时，下次想复习面试手撕题的时候，找起来方便，也节省时间。









## DOM

### 实现一个事件委托（易错）

事件委托这里就不阐述了，比如给li绑定点击事件

看错误版，(容易过的，看**面试官水平了**)👇

```js

ul.addEventListener('click', function (e) {
            console.log(e,e.target)
            if (e.target.tagName.toLowerCase() === 'li') {
                console.log('打印')  // 模拟fn
            }
})
```

**有个小bug，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对**👇

```
<ul id="xxx">下面的内容是子元素1
        <li>li内容>>> <span> 这是span内容123</span></li>
        下面的内容是子元素2
        <li>li内容>>> <span> 这是span内容123</span></li>
        下面的内容是子元素3
        <li>li内容>>> <span> 这是span内容123</span></li>
</ul>
```

这样子的场景就是不对的，那我们看看高级版本👇

```js
		function delegate(element, eventType, selector, fn) {
            element.addEventListener(eventType, e => {
                let el = e.target
                while (!el.matches(selector)) {
                    if (element === el) {
                        el = null
                        break
                    }
                    el = el.parentNode
                }
                el && fn.call(el, e, el)
            },true)
            return element
        }
```



### 实现一个可以拖拽的DIV

这个题目看起来简单，你可以试一试30分钟能不能完成，直接贴出代码吧👇

```
<div id="xxx"></div>
```

```js
var dragging = false
var position = null

xxx.addEventListener('mousedown',function(e){
  dragging = true
  position = [e.clientX, e.clientY]
})


document.addEventListener('mousemove', function(e){
  if(dragging === false) return null
  const x = e.clientX
  const y = e.clientY
  const deltaX = x - position[0]
  const deltaY = y - position[1]
  const left = parseInt(xxx.style.left || 0)
  const top = parseInt(xxx.style.top || 0)
  xxx.style.left = left + deltaX + 'px'
  xxx.style.top = top + deltaY + 'px'
  position = [x, y]
})
document.addEventListener('mouseup', function(e){
  dragging = false
})
```



## CSS





## JS

### 手写防抖和节流函数

**节流throttle**，规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。场景👇

- scroll滚动事件，每隔特定描述执行回调函数
- input输入框，每个特定时间发送请求或是展开下拉列表，（防抖也可以）

节流重在加锁**flag = false**

```
function throttle(fn, delay) {
    let flag = true,
        timer = null
    return function(...args) {
        let context = this
        if(!flag) return
        
        flag = false
        clearTimeout(timer)
        timer = setTimeout(function() {
            fn.apply(context,args)
            flag = true
        },delay)
    }
}
```



**防抖debounce**,在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。场景👇

- 浏览器窗口大小resize避免次数过于频繁
- 登录，发短信等按钮避免发送多次请求
- 文本编辑器实时保存

防抖重在清零**clearTimeout(timer)**

```
function debounce(fn, delay) {
    let timer = null
    return function(...args) {
        let context = this
        if(timer) clearTimeout(timer)
        timer = setTimeout(function(){
            fn.apply(context,args)
        },delay)
    }
}
```







### 手写AJAX



### 深拷贝

深拷贝解决的就是**共用内存地址所导致的数据错乱问题**

思路：

- 递归

- 判断类型

- 检查环（也叫循环引用）

- 需要忽略原型

```
function deepClone(obj, map = new WeakMap()) {
    if (obj instanceof RegExp) return new RegExp(obj);
    if (obj instanceof Date) return new Date(obj);

    if (obj == null || typeof obj != 'object') return obj;
    if (map.has(obj)) {
        return map.get(obj);
    }
    let t = new obj.constructor();
    map.set(obj, t);
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            t[key] = deepClone(obj[key], map);
        }
    }
    return t;
}
//测试用例
let obj = {
    a: 1,
    b: {
        c: 2,
        d: 3
    },
    d: new RegExp(/^\s+|\s$/g)
}

let clone_obj = deepClone(obj)
obj.d = /^\s|[0-9]+$/g
console.log(clone_obj)
console.log(obj)
```





### 用正则实现 trim()

去掉首位多余的空格👇

```
String.prototype.trim = function(){
    return this.replace(/^\s+|\s+$/g, '')
}
//或者 
function trim(string){
    return string.replace(/^\s+|\s+$/g, '')
}
```





### 实现数组去重



实现Object.create方法



### 手写call和apply



### 手写bind



### 实现new操作



### 实现一个对象类型的函数

核心：Object.prototype.toString 

```
let isType = (type) => (obj) => Object.prototype.toString.call(obj) === `[object ${type}]`

// let isArray = isType('Array')
// let isFunction = isType('Function')
// console.log(isArray([1,2,3]),isFunction(Map))
```

isType函数👆，也属于**偏函数**的范畴，偏函数实际上是返回了一个包含**预处理参数**的新函数。



### 实现instanceof

**instanceof** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

语法👇

```
object instanceof constructor
object 某个实例对象
construtor 某个构造函数
```

原型链的向上找，找到原型的最顶端，也就是Object.prototype，代码👇

```
function my_instance_of(leftVaule, rightVaule) {
    if(typeof leftVaule !== 'object' || leftVaule === null) return false;
    let rightProto = rightVaule.prototype,
        leftProto = leftVaule.__proto__;
    while (true) {
        if (leftProto === null) {
            return false;
        }
        if (leftProto === rightProto) {
            return true;
        }
        leftProto = leftProto.__proto__
    }
}

```



### 实现柯里化函数

柯里化就是把接受**多个参数**的函数变换成接受一个**单一参数**的函数，并且返回接受**余下参数**返回结果的一种应用。

思路：

- 判断传递的参数是否达到执行函数的fn个数
- 没有达到的话，继续返回新的函数，并且返回curry函数传递剩余参数



```
let currying = (fn, ...args) =>
            fn.length > args.length ?
            (...arguments) => currying(fn, ...args, ...arguments) :
            fn(...args)
```

测试用例👇

```
let addSum = (a, b, c) => a+b+c
let add = curry(addSum)
console.log(add(1)(2)(3))
console.log(add(1, 2)(3))
console.log(add(1,2,3))
```





### 实现数组flat



### 实现sleep



某个时间后就去执行某个函数，使用Promise封装👇

```
function sleep(fn, time) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(fn);
        }, time);
    });
}
let saySomething = (name) => console.log(`hello,${name}`)
async function autoPlay() {
    let demo = await sleep(saySomething('TianTian'),1000)
    let demo2 = await sleep(saySomething('李磊'),1000)
    let demo3 = await sleep(saySomething('掘金的好友们'),1000)
}
autoPlay()
```



### 实现数组reduce



### 用发布订阅模式实现EventEmit



### 实现Promise.all和race



```
// 实现Promise.all 以及 race

Promise.myall = function (arr) {
    return new Promise((resolve, reject) => {
        if (arr.length === 0) {
            return resolve([])
        } else {
            let res = [],
                count = 0
            for (let i = 0; i < arr.length; i++) {
                // 同时也能处理arr数组中非Promise对象
                Promise.resolve(arr[i]).then(data => {
                    res[i] = data
                    if (++count === arr.length)
                        resolve(res)
                }, err => {
                    reject(err)
                })
            }
        }
    })
}

Promise.myrace = function (arr) {
    return new Promise((resolve, reject) => {
        for (let i = 0; i < arr.length; i++) {
            // 同时也能处理arr数组中非Promise对象
            Promise.resolve(arr[i]).then(resolve, reject)
        }
    })
}
```

测试用例👇

```
		// 测试用例
        let p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(1)
            }, 2000);
        });
        let p2 = new Promise((resolve) => {
            resolve(2);
        });
        let p3 = new Promise((resolve) => {
            setTimeout(() => {
                resolve(3);
            },4);
        });

        Promise.myall([p3, p1, p2, 3,4]).then(data => {
            // 按传入数组的顺序打印
            console.log(data); // [3, 1, 2]
        });

        Promise.myrace([p1,p2, p3, 3, 5]).then(data => {
            // 谁快就是谁
            console.log(data); // 2
        })
```

