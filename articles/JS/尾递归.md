### 前言

经常看到关于`尾递归`这三个词，递归很多时候，都离不开我们，废话不多说，这次我们梳理一遍关于递归那些事。





在这里关于递归，这里就不赘述了，有兴趣的可以去查一查资料。



需要了解如何优化尾递归的话，我们需要从最开始讲起。

- 什么是尾调用
- 什么是尾递归
- 如何优化尾递归



### 尾调用

从字面理解，自然而言就是在**函数的尾部返回一个函数的调用**，通常来说，指的是函数执行的最后一步。

举个例子👇

```js
const fn = () => f1() || f2()
// 这里的话, f2函数有可能是尾调用,f1不可能是尾调用
```

为什么f1函数不是呢，我们看这个函数的等价形式👇

```js
const fn = function () {
    const flag = f1()
    if(flag) {
        return flag
    } else {
        return f2()
    }
}
```

似乎写到这里，根据尾调用定义，我们就明白了，只有f2函数是在尾部调用。



--------



说到这里，为什么要说尾调用呢?我们事先想一想**传统的递归**，典型的就是首先执行递归调用，然后根据这个递归的返回值并结算结果，那么传统的递归缺点有哪些呢👇

- 效率低，占内存。
- 如果递归链过长，可能会**stack overflow**



那么我们是不是可以做优化呢，这就可以涉及上面提到的尾调用，它的原理是啥呢👇



按照[阮一峰老师在es6的函数扩展](http://es6.ruanyifeng.com/#docs/function)中的解释就是：函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。



这里的“调用帧”和“调用栈”，说的应该就是“执行环境”和“调用栈”。因为尾调用时函数的最后一部操作，所以不再需要保留外层的调用帧，而是直接取代外层的调用帧，所以可以起到一个优化的作用。





说到这里的话，当你明白了尾调用的话，那么问题来了，如何去优化尾调用呢？有没有想过这个问题？

- 首先问题的提出以及优化，肯定是因为使用尾调用肯定会缺陷的，那么缺陷是啥呢
- 其实懂的同学都已经知道，函数的执行肯定跟栈有关系，有个叫执行栈的概念，那我们一起来看看







### 参考

- [尾调用和尾递归](https://juejin.im/post/6844903590033621006)
- https://github.com/HolyZheng/holyZheng-blog/issues/17